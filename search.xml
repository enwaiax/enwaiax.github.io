<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 开发之序列化与反序列化：pickle、json 模块使用详解</title>
      <link href="/posts/16968/"/>
      <url>/posts/16968/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="# 引言" class="headerlink" title="引言"></a>引言 </h2><p> 在日常开发中，所有的对象都是存储在内存当中，尤其是像 python 这样的坚持一切接对象的高级程序设计语言，一旦关机，在写在内存中的数据都将不复存在。另一方面，存储在内存够中的对象由于编程语言、网络环境等等因素，很难在网络中进行传输交互。由此，就诞生了一种机制，可以实现内存中的对象与方便持久化在磁盘中或在网络中进行交互的数据格式（str、bites)之间的相互转换。这种机制就叫序列化与反序列化：</p><p><strong>序列化：将内存中的不可持久化和传输对象转换为可方便持久化和传输对象的过程。</strong></p><p><strong>反序列化：将可持久化和传输对象转换为不可持久化和传输对象的过程。</strong></p><p>Python 中提供 pickle 和 json 两个模块来实现序列化与反序列化，pickle 模块和 json 模块 dumps()、dump()、loads()、load()这是个函数，其中 dumps()、dump()用于实现序列化，loads()、load()用于实现反序列化。下面，我们分别对 pickle 和 json 模块进行介绍。</p><h2 id="pickle- 模块"><a href="#pickle- 模块" class="headerlink" title="pickle 模块"></a>pickle 模块 </h2><p>​ pickle 模块的 dumps()、dump()、loads()、load() 是个函数按功能划分可以分为两组：</p><ul><li>序列化：dumps()、dump()</li><li>反序列化：loads()、load()</li></ul><p><strong>dumps()与 dump()的区别是 dumps()只是单纯得将对象序列化，而 dump()会在序列化之后将结果写入到文件当中；与之对应，loads()与 load()区别至于 loads()是对 dumps 的序列化结果进行反序列化，而 load()会从文件中读取内容进行反序列化。</strong></p><h3 id="dumps- 与 -loads"><a href="#dumps- 与 -loads" class="headerlink" title="dumps()与 loads()"></a><strong>dumps()与 loads()</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_dict = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27; 张三 &#x27;</span> , <span class="string">&#x27;age&#x27;</span>:<span class="number">30</span> , <span class="string">&#x27;isMarried&#x27;</span>:<span class="literal">False</span>&#125; <span class="comment"># 定义一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_str = pickle.dumps(p_dict) <span class="comment"># 序列化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p_dict)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p_str)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_str</span><br><span class="line"><span class="string">b&#x27;\x80\x03&#125;q\x00(X\x04\x00\x00\x00nameq\x01X\x06\x00\x00\x00\xe5\xbc\xa0\xe4\xb8\x89q\x02X\x03\x00\x00\x00ageq\x03K\x1eX\t\x00\x00\x00isMarriedq\x04\x89u.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = pickle.loads(p_str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 张三 &#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;isMarried&#x27;</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure><p>可以看到，反序列化后得到的 p 和序列化之前的 p_dict 内容是一模一样的。不过，p 与 p_dict 已经是两个不同的对象了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(p)==<span class="built_in">id</span>(p_dict)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="dump- 与 -load"><a href="#dump- 与 -load" class="headerlink" title="dump()与 load()"></a>dump()与 load()</h3><p>序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_dict = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27; 张三 &#x27;</span> , <span class="string">&#x27;age&#x27;</span>:<span class="number">30</span> , <span class="string">&#x27;isMarried&#x27;</span>:<span class="literal">False</span>&#125; <span class="comment"># 定义一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file = <span class="built_in">open</span>(<span class="string">&quot;my_dump.txt&quot;</span>, <span class="string">&quot;wb&quot;</span>) <span class="comment"># 因为序列化只有的是 bites 类型，所以必须以 wb 模式打开</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pickle.dump(p_dict, file)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</span><br></pre></td></tr></table></figure><p>此时，通过上面代码我们已经将 p_dict 序列化成功，并写入到了一个名为 my_dump.txt 文件中。你可以找到这个文件，然后将它拷贝到任何电脑上进行反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>file=<span class="built_in">open</span>(<span class="string">&quot;my_dump.txt&quot;</span>,<span class="string">&quot;rb&quot;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p=pickle.load(file)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 张三 &#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;isMarried&#x27;</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure><p>反序列化后得到的内容与序列化之前的内容完全一样。体会到序列化与反序列化的作用了吗？序列化之后的内容可以方便得保存到磁盘中，电脑关机也不怕。</p><h2 id="json- 模块"><a href="#json- 模块" class="headerlink" title="json 模块"></a>json 模块 </h2><p> 如果你阅读并理解了上文中关于 pickle 的部门内容，对于这一部分的 json 模块内容，你可以不费吹灰之力掌握。上文中说到过，与 pickle 一样，json 模块也提供了 dumps()、dump()、loads()、load()则是个函数，且其中区别也与 pickle 中是个函数的区别是一样的。</p><h3 id="dumps- 与 -loads-1"><a href="#dumps- 与 -loads-1" class="headerlink" title="dumps()与 loads()"></a>dumps()与 loads()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_dict = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27; 张三 &#x27;</span> , <span class="string">&#x27;age&#x27;</span>:<span class="number">30</span> , <span class="string">&#x27;isMarried&#x27;</span>:<span class="literal">False</span>&#125; <span class="comment"># 定义一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_dict = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27; 张三 &#x27;</span> , <span class="string">&#x27;age&#x27;</span>:<span class="number">30</span> , <span class="string">&#x27;isMarried&#x27;</span>:<span class="literal">False</span>&#125; <span class="comment"># 定义一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_str = json.dumps(p_dict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p_str)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_str</span><br><span class="line"><span class="string">&#x27;&#123;&quot;name&quot;: &quot;\\u5f20\\u4e09&quot;, &quot;age&quot;: 30, &quot;isMarried&quot;: false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以看到，json 序列化之后得到的是 json 格式字符串，但上述 json 字符串中，中文部分内容显示为了“乱码”。怎么办呢？<strong>json 的 dumps()函数（dump()函数也有）中提供了一个 ensure_ascii 参数，将该参数的值设置为 False，可令序列化后中文依然正常显示。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_str2 = json.dumps(p_dict, ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_str2</span><br><span class="line"><span class="string">&#x27;&#123;&quot;name&quot;: &quot; 张三 &quot;, &quot;age&quot;: 30, &quot;isMarried&quot;: false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>接着上面的内容进行反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1 = json.loads(p_str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p1</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 张三 &#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;isMarried&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = json.loads(p_str)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 张三 &#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;isMarried&#x27;</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="dump- 与 -load-1"><a href="#dump- 与 -load-1" class="headerlink" title="dump()与 load()"></a>dump()与 load()</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p_dict = &#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27; 张三 &#x27;</span> , <span class="string">&#x27;age&#x27;</span>:<span class="number">30</span> , <span class="string">&#x27;isMarried&#x27;</span>:<span class="literal">False</span>&#125; <span class="comment"># 定义一个字典</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file = <span class="built_in">open</span>(<span class="string">&#x27;d:/mydump.txt&#x27;</span> , <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump(p_dict , file)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</span><br></pre></td></tr></table></figure><p>当然，你也可以加上 ensure_ascii 这一参数，并将其值设置为 False，这样你打开 mydump.txt 文件里面的中文就能正常显示。（执行完代码之后，本地会有一个 mydump.txt 文件，诸位可以验证该内容）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>file = <span class="built_in">open</span>(<span class="string">&#x27;d:/mydump.txt&#x27;</span> , <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dump(p_dict , file , ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</span><br></pre></td></tr></table></figure><p>继续反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>file = <span class="built_in">open</span>(<span class="string">&#x27;d:/mydump.txt&#x27;</span> , <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = json.load(file)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>file.close()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 张三 &#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;isMarried&#x27;</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure><p>通过上面内容，pickle 和 json 模块关于序列化与反序列化的操作就介绍完了。我们可以发现，pickle 与 json 两个模块无论是在函数名，还是在功能上，都是机器相似的。既然这样，有了 pickle 模块，为什么还有 json 模块的诞生呢？接下来来说说 pickle 与 json 模块的区别。</p><h2 id="pickle- 模块与 -json- 模块的区别"><a href="#pickle- 模块与 -json- 模块的区别" class="headerlink" title="pickle 模块与 json 模块的区别"></a>pickle 模块与 json 模块的区别</h2><p><strong>（1）pickle 模块用于 Python 语言特有的类型和用户自定义类型与 Python 基本数据类型之间的转换</strong></p><p><strong>json 模块用于字符串和 python 数据类型间进行转换。</strong>如下所示，我们自定义一个 Person 类，分别用 pickle 和 json 进行序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self , name , age , isMarried</span>):</span><br><span class="line">self.name = name</span><br><span class="line">self.age = age</span><br><span class="line">self.isMarried = isMarried</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">&#x27; 张三 &#x27;</span> , <span class="number">30</span> , <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>使用 pickle 模块进行序列化与反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">&#x27; 张三 &#x27;</span> , <span class="number">30</span> , <span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pickle</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp = pickle.dumps(p)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(pp)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;bytes&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pp</span><br><span class="line"><span class="string">b&#x27;\x80\x03c__main__\nPerson\nq\x00)\x81q\x01&#125;q\x02(X\x04\x00\x00\x00nameq\x03X\x06\x00\x00\x00\xe5\xbc\xa0\xe4\xb8\x89q\x04X\x03\x00\x00\x00ageq\x05K\x1eX\t\x00\x00\x00isMarriedq\x06\x89ub.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2 = pickle.loads(pp)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p2)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p2.name</span><br><span class="line"><span class="string">&#x27; 张三 &#x27;</span></span><br></pre></td></tr></table></figure><p>甚至 pickle 模块还能够对 Peron 本身进行序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>per = pickle.dumps(Person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>per</span><br><span class="line"><span class="string">b&#x27;\x80\x03c__main__\nPerson\nq\x00.&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>per2 = pickle.loads(per)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>per2</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>如果用 json 对 Person 实例对象进行序列化，就会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> json</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p = Person(<span class="string">&#x27; 张三 &#x27;</span> , <span class="number">30</span> , <span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>json.dumps(p)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">File <span class="string">&quot;&lt;pyshell#49&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">json.dumps(p)</span><br><span class="line">……</span><br><span class="line">TypeError: Object of <span class="built_in">type</span> <span class="string">&#x27;Person&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> JSON serializable</span><br></pre></td></tr></table></figure><p><strong>如果非要用 json 对 Person 对象进行序列化，必须先定义一个将 Person 对象转化为字典（dict)的方法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">person2dict</span>(<span class="params">per</span>):</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line"><span class="string">&#x27;name&#x27;</span>:per.name ,</span><br><span class="line"><span class="string">&#x27;age&#x27;</span>:per.age ,</span><br><span class="line"><span class="string">&#x27;isMarried&#x27;</span>:per.isMarried</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3 = json.dumps(p , default=person2dict)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p3)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3</span><br><span class="line"><span class="string">&#x27;&#123;&quot;name&quot;: &quot;\\u5f20\\u4e09&quot;, &quot;age&quot;: 30, &quot;isMarried&quot;: false&#125;&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3 = json.dumps(p , default=person2dict , ensure_ascii=<span class="literal">False</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p3)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;str&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p3</span><br><span class="line"><span class="string">&#x27;&#123;&quot;name&quot;: &quot; 张三 &quot;, &quot;age&quot;: 30, &quot;isMarried&quot;: false&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>当然，也不能直接进行反序列化，不然也只会得到一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>p4 = json.loads(p3)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p4)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;dict&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p4</span><br><span class="line">&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27; 张三 &#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;isMarried&#x27;</span>: <span class="literal">False</span>&#125;</span><br></pre></td></tr></table></figure><p>此时，也要定义一个将字典转换为 Person 类实例的方法，在进行反序列化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">dict2person</span>(<span class="params">d</span>):</span><br><span class="line"><span class="keyword">return</span> Person(d[<span class="string">&#x27;name&#x27;</span>],d[<span class="string">&#x27;age&#x27;</span>],d[<span class="string">&#x27;isMarried&#x27;</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p5 = json.loads(p3 , object_hook=dict2person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(p5)</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Person&#x27;</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>p5.name</span><br><span class="line"><span class="string">&#x27; 张三 &#x27;</span></span><br></pre></td></tr></table></figure><p><strong>（2）pickle 序列化结果为 bites 类型，只适合于 Python 机器之间的交互。</strong></p><p><strong>json 序列化结果为 str 类型，能够被多种语言识别，可用于与其他程序设计语言交互。</strong></p><p>目前，JSON 格式字符串已经成为网络传输中的一种标准格式，所以在 web 后台开发中通常用 json 模块来序列化而不是 pickle 模块。</p><p><strong>JSON 和 Python 内置的数据类型对应如下：</strong></p><table><thead><tr><th>JSON 类型</th><th>Python 类型</th></tr></thead><tbody><tr><td>{}</td><td>dict</td></tr><tr><td>[]</td><td>list</td></tr><tr><td>“string”</td><td>‘str’或 u’unicode’</td></tr><tr><td>1234.56</td><td>int 或 float</td></tr><tr><td>true&#x2F;false</td><td>True&#x2F;False</td></tr><tr><td>null</td><td>None</td></tr></tbody></table><h2 id="总结"><a href="# 总结" class="headerlink" title="总结"></a>总结</h2><ol><li><strong>序列化与反序列化是为了解决内存中对象的持久化与传输问题；</strong></li><li><strong>Python 中提供了 pickle 和 json 两个模块进行序列化与反序列化；</strong></li><li><strong>dumps()和 dump()用于序列化，loads()和 load()用于反序列化；</strong></li><li><strong>pickle 模块能序列化任何对象，序列化结果为 bites 类型，只适合于 Python 机器之间交互；</strong></li></ol><p><strong>json 模块只能序列化 Python 基本类型，序列化结果为 json 格式字符串，适合不同开发语言之间交互。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 中输出表格的两种方式</title>
      <link href="/posts/49253/"/>
      <url>/posts/49253/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 本文主要介绍 python 中输出表格的两种方式，即分别使用<code>tabulate</code> 和 <code>prettytable</code>。</p><h2 id="tabulate"><a href="#tabulate" class="headerlink" title="tabulate"></a>tabulate</h2><h3 id="安装、导入"><a href="# 安装、导入" class="headerlink" title="安装、导入"></a>安装、导入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pip install tabulate</span><br><span class="line"></span><br><span class="line">from tabulate import tabulate</span><br></pre></td></tr></table></figure><h3 id="从 -list- 生成表格"><a href="# 从 -list- 生成表格" class="headerlink" title="从 list 生成表格"></a>从 list 生成表格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; table = [[&#x27;First Name&#x27;, &#x27;Last Name&#x27;, &#x27;Age&#x27;], [&#x27;John&#x27;, &#x27;Smith&#x27;, 39], [&#x27;Mary&#x27;, &#x27;Jane&#x27;, 25], [&#x27;Jennifer&#x27;, &#x27;Doe&#x27;, 28]]</span><br><span class="line">&gt;&gt;&gt; print(tabulate(table))</span><br><span class="line">----------  ---------  ---</span><br><span class="line">First Name  Last Name  Age</span><br><span class="line">John        Smith      39</span><br><span class="line">Mary        Jane       25</span><br><span class="line">Jennifer    Doe        28</span><br></pre></td></tr></table></figure><h4 id="设定表头"><a href="# 设定表头" class="headerlink" title="设定表头"></a>设定表头</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(tabulate(table, headers=&#x27;firstrow&#x27;))</span><br><span class="line">First Name    Last Name      Age</span><br><span class="line">------------  -----------  -----</span><br><span class="line">John          Smith           39</span><br><span class="line">Mary          Jane            25</span><br><span class="line">Jennifer      Doe             28</span><br></pre></td></tr></table></figure><h4 id="传参修改样式"><a href="# 传参修改样式" class="headerlink" title="传参修改样式"></a>传参修改样式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(tabulate(table, headers=&#x27;firstrow&#x27;, tablefmt=&#x27;fancy_grid&#x27;))</span><br><span class="line">╒══════════════╤═════════════╤═══════╕</span><br><span class="line">│ First Name   │ Last Name   │   Age │</span><br><span class="line">╞══════════════╪═════════════╪═══════╡</span><br><span class="line">│ John         │ Smith       │    39 │</span><br><span class="line">├──────────────┼─────────────┼───────┤</span><br><span class="line">│ Mary         │ Jane        │    25 │</span><br><span class="line">├──────────────┼─────────────┼───────┤</span><br><span class="line">│ Jennifer     │ Doe         │    28 │</span><br><span class="line">╘══════════════╧═════════════╧═══════╛</span><br><span class="line">&gt;&gt;&gt; print(tabulate(table, headers=&#x27;firstrow&#x27;, tablefmt=&#x27;grid&#x27;))</span><br><span class="line">+--------------+-------------+-------+</span><br><span class="line">| First Name   | Last Name   |   Age |</span><br><span class="line">+==============+=============+=======+</span><br><span class="line">| John         | Smith       |    39 |</span><br><span class="line">+--------------+-------------+-------+</span><br><span class="line">| Mary         | Jane        |    25 |</span><br><span class="line">+--------------+-------------+-------+</span><br><span class="line">| Jennifer     | Doe         |    28 |</span><br><span class="line">+--------------+-------------+-------+</span><br></pre></td></tr></table></figure><h3 id="使用 -dict- 生成表格"><a href="# 使用 -dict- 生成表格" class="headerlink" title="使用 dict 生成表格"></a>使用 dict 生成表格</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; info = &#123;&#x27;First Name&#x27;: [&#x27;John&#x27;, &#x27;Mary&#x27;, &#x27;Jennifer&#x27;], &#x27;Last Name&#x27;: [&#x27;Smith&#x27;, &#x27;Jane&#x27;, &#x27;Doe&#x27;], &#x27;Age&#x27;: [39, 25, 28]&#125;</span><br><span class="line">&gt;&gt;&gt; print(tabulate(info, headers=&#x27;keys&#x27;, tablefmt=&#x27;grid&#x27;))</span><br><span class="line">+--------------+-------------+-------+</span><br><span class="line">| First Name   | Last Name   |   Age |</span><br><span class="line">+==============+=============+=======+</span><br><span class="line">| John         | Smith       |    39 |</span><br><span class="line">+--------------+-------------+-------+</span><br><span class="line">| Mary         | Jane        |    25 |</span><br><span class="line">+--------------+-------------+-------+</span><br><span class="line">| Jennifer     | Doe         |    28 |</span><br><span class="line">+--------------+-------------+-------+</span><br></pre></td></tr></table></figure><h3 id="显示索引"><a href="# 显示索引" class="headerlink" title="显示索引"></a>显示索引</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(tabulate(info, headers=&#x27;keys&#x27;, tablefmt=&#x27;grid&#x27;, showindex=True))</span><br><span class="line">+----+--------------+-------------+-------+</span><br><span class="line">|    | First Name   | Last Name   |   Age |</span><br><span class="line">+====+==============+=============+=======+</span><br><span class="line">|  0 | John         | Smith       |    39 |</span><br><span class="line">+----+--------------+-------------+-------+</span><br><span class="line">|  1 | Mary         | Jane        |    25 |</span><br><span class="line">+----+--------------+-------------+-------+</span><br><span class="line">|  2 | Jennifer     | Doe         |    28 |</span><br><span class="line">+----+--------------+-------------+-------+</span><br></pre></td></tr></table></figure><h2 id="prettytable"><a href="#prettytable" class="headerlink" title="prettytable"></a>prettytable</h2><h3 id="安装、导入 -1"><a href="# 安装、导入 -1" class="headerlink" title="安装、导入"></a>安装、导入</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install prettytable</span><br><span class="line">from prettytable import PrettyTable</span><br></pre></td></tr></table></figure><h4 id=""><a href="#"class="headerlink"title=""></a></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tb = PrettyTable() # 生成表格对象</span><br><span class="line">tb.field_names = [&#x27;Index&#x27;, 0, 1, 2, 3] # 定义表头</span><br><span class="line">tb.add_row([&#x27;Alice&#x27;,1,2,3,4]) # 添加一行，列是 column</span><br><span class="line">tb.add_row([&#x27;Bob&#x27;,2,3,4,5])</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="# 参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/485136394">tabulate：在 Python 中可如此优雅地创建表格</a></li><li><a href="https://zhuanlan.zhihu.com/p/545833765">prettytable：一款可完美格式化输出的 Python 库</a></li><li><a href="https://blog.csdn.net/qq_43901693/article/details/104920856">Python 常用类库学习之 tabulate</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sed 备忘清单</title>
      <link href="/posts/24675/"/>
      <url>/posts/24675/</url>
      
        <content type="html"><![CDATA[<h2 id="入门"><a href="# 入门" class="headerlink" title="入门"></a>入门 </h2><h3 id="Sed- 用法"><a href="#Sed- 用法" class="headerlink" title="Sed 用法"></a>Sed 用法</h3><p> 语法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed [options] <span class="built_in">command</span> [input-file]</span></span><br></pre></td></tr></table></figure><p>带管道</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cat</span> report.txt | sed <span class="string">&#x27;s/Nick/John/g&#x27;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;123abc&#x27;</span> | sed <span class="string">&#x27;s/[0-9]+//g&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="选项示例"><a href="# 选项示例" class="headerlink" title="选项示例"></a>选项示例</h3><table><thead><tr><th>参数</th><th>示例</th><th>描述</th></tr></thead><tbody><tr><td><code>-i</code></td><td>sed -ibak ‘s&#x2F;On&#x2F;Off&#x2F;‘ php.ini</td><td>直接备份和修改输入文件</td></tr><tr><td><code>-E</code></td><td>sed -E ‘s&#x2F;[0-9]+&#x2F;&#x2F;g’ input-file</td><td>使用扩展正则表达式</td></tr><tr><td><code>-n</code></td><td>sed -n ‘3 p’ config.conf</td><td>禁止默认图案空间打印</td></tr><tr><td><code>-f</code></td><td>sed -f script.sed config.conf</td><td>执行 sed 脚本文件</td></tr><tr><td><code>-e</code></td><td>sed -e ‘command1’ -e ‘command2’ input-file</td><td>执行多个 sed 命令</td></tr></tbody></table><h3 id="多个命令"><a href="# 多个命令" class="headerlink" title="多个命令"></a>多个命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | sed -e <span class="string">&#x27;s/h/H/g&#x27;</span> -e <span class="string">&#x27;s/w/W/g&#x27;</span></span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>使用 <code>-e</code> 执行多个 sed 命令</p><h3 id="Sed- 脚本"><a href="#Sed- 脚本" class="headerlink" title="Sed 脚本"></a>Sed 脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;s/h/H/g&#x27;</span> &gt;&gt; hello.sed</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&#x27;s/w/W/g&#x27;</span> &gt;&gt; hello.sed</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">echo</span> <span class="string">&quot;hello world&quot;</span> | sed -f hello.sed</span></span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>使用 <code>-f</code> 执行 sed 脚本文件</p><h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/g&#x27;</span> file.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/g&#x27;</span> file.txt &gt; new.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/g&#x27;</span> -i file.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/g&#x27;</span> -i.backup file.txt</span></span><br></pre></td></tr></table></figure><h2 id="Sed- 命令"><a href="#Sed- 命令" class="headerlink" title="Sed 命令"></a>Sed 命令 </h2><h3 id="命令"><a href="# 命令" class="headerlink" title="命令"></a> 命令</h3><table><thead><tr><th align="left">命令</th><th align="left">示例</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>p</code></td><td align="left">sed -n ‘1,4 p’ input.txt</td><td align="left">打印第 1-4 行</td></tr><tr><td align="left"><code>p</code></td><td align="left">sed -n -e ‘1,4 p’ -e ‘6,7 p’ input.txt</td><td align="left">打印第 1-4 行和第 6-7 行</td></tr><tr><td align="left"><code>d</code></td><td align="left">sed ‘1,4 d’ input.txt</td><td align="left">打印除 1-4 之外的行</td></tr><tr><td align="left"><code>w</code></td><td align="left">sed -n ‘1,4 w output.txt’ input.txt</td><td align="left">将模式空间写入文件</td></tr><tr><td align="left"><code>a</code></td><td align="left">sed ‘2 a new-line’ input.txt</td><td align="left">在后面追加一行</td></tr><tr><td align="left"><code>i</code></td><td align="left">sed ‘2 i new-line’ input.txt</td><td align="left">在前面插入行</td></tr></tbody></table><h3 id="空间命令"><a href="# 空间命令" class="headerlink" title="空间命令"></a>空间命令</h3><table><thead><tr><th align="left">命令</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>n</code></td><td align="left">打印模式空间，空模式空间，读取下一行</td></tr><tr><td align="left"><code>x</code></td><td align="left">用保持空间交换模式空间</td></tr><tr><td align="left"><code>h</code></td><td align="left">复制模式空间以保持空间</td></tr><tr><td align="left"><code>H</code></td><td align="left">追加模式空间以保持空间</td></tr><tr><td align="left"><code>g</code></td><td align="left">将保持空间复制到模式空间</td></tr><tr><td align="left"><code>G</code></td><td align="left">将保持空间附加到模式空间</td></tr></tbody></table><h3 id="Flags"><a href="#Flags" class="headerlink" title="Flags"></a>Flags</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/[flags]&#x27;</span> [input-file]</span></span><br></pre></td></tr></table></figure><hr><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td><code>g</code></td><td>全球替代</td></tr><tr><td><code>1,2...</code></td><td>替换第 n 次出现</td></tr><tr><td><code>p</code></td><td>仅打印替换的行</td></tr><tr><td><code>w</code></td><td>仅将替换的行写入文件</td></tr><tr><td><code>I</code></td><td>搜索时忽略大小写</td></tr><tr><td><code>e</code></td><td>在命令行中替换并执行</td></tr></tbody></table><h3 id="循环命令"><a href="# 循环命令" class="headerlink" title="循环命令"></a>循环命令</h3><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>b label</code></td><td>分支到标签（用于循环）</td></tr><tr><td><code>t label</code></td><td>仅在成功替换时分支到标签（用于循环）</td></tr><tr><td><code>:label</code></td><td>b 和 t 命令的标签（用于循环）</td></tr><tr><td><code>N</code></td><td>将下一行追加到模式空间</td></tr><tr><td><code>P</code></td><td>多行打印第一行</td></tr><tr><td><code>D</code></td><td>删除多行中的第一行</td></tr></tbody></table><h3 id="杂项标志"><a href="# 杂项标志" class="headerlink" title="杂项标志"></a>杂项标志</h3><table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody><tr><td><code>/ | ^ @ ! #</code></td><td>替换分隔符可以是任何字符</td></tr><tr><td><code>&amp;</code></td><td>获取匹配的模式</td></tr><tr><td><code>() \1 \2 \3</code></td><td>使用 <code>(</code> 和 <code>)</code> 进行分组。<br>使用 <code>\1</code>、<code>\2</code> 替换来引用组</td></tr></tbody></table><h2 id="Sed- 示例"><a href="#Sed- 示例" class="headerlink" title="Sed 示例"></a>Sed 示例 </h2><h3 id="替换文本"><a href="# 替换文本" class="headerlink" title="替换文本"></a> 替换文本 </h3><p> 替换所有出现的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/g&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>仅替换第 n 次出现的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/old/new/2&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>仅在第 5 行替换替换字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;5 s/old/new/&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>将“world”替换为“universe”，但前提是该行以“hello”开头</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/hello/s/world/universe/&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>从每行的末尾删除“\”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/\\$//&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除每行开头的所有空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/^\s*//&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除评论。 即使是那些在行尾的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;s/#.*$//&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><h3 id="搜索文本"><a href="# 搜索文本" class="headerlink" title="搜索文本"></a>搜索文本 </h3><p> 搜索字符串并仅打印匹配的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -n <span class="string">&#x27;/hello/p&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>不区分大小写的搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -n <span class="string">&#x27;/hello/Ip&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>搜索字符串，但仅输出不匹配的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -n <span class="string">&#x27;/hello/!p&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><h3 id="追加行"><a href="# 追加行" class="headerlink" title="追加行"></a>追加行 </h3><p> 在第 2 行之后追加一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;2a Text after line 2&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>在文件末尾追加一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;$a THE END!&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>从第 3 行开始，每 3 行后追加一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;3~3a Some text&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><h3 id="编号"><a href="# 编号" class="headerlink" title="编号"></a>编号 </h3><p> 文件的数字行（简单的左对齐）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed = file.txt | sed <span class="string">&#x27;N;s/\n/\t/&#x27;</span></span></span><br></pre></td></tr></table></figure><p>文件的数字行（数字在左，右对齐）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed = file.txt | sed <span class="string">&#x27;N; s/^/   /; s/ *\(.\&#123;6,\&#125;\)\n/\1  /&#x27;</span></span></span><br></pre></td></tr></table></figure><p>文件的数字行，但如果行不为空，则仅打印数字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/./=&#x27;</span> file.txt | sed <span class="string">&#x27;/./N; s/\n/ /&#x27;</span></span></span><br></pre></td></tr></table></figure><p>计算行数（模拟“wc -l”）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed -n <span class="string">&#x27;$=&#x27;</span></span></span><br></pre></td></tr></table></figure><h3 id="前置行"><a href="# 前置行" class="headerlink" title="前置行"></a>前置行 </h3><p> 在第 5 行之前插入文本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;5i line number five&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>在包含“hello”的每一行之前插入“示例：”</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/hello/i Example: &#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><h3 id="删除行"><a href="# 删除行" class="headerlink" title="删除行"></a>删除行 </h3><p> 删除文件中的第 5-7 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;5,7d&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除从第 3 行开始的每 2 行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;3~2d&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除文件的最后一行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;$d&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除以“Hello”开头的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/^Hello/d&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除所有空行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/^$/d&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><p>删除以“#”开头的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/^#/d&#x27;</span> file.txt</span></span><br></pre></td></tr></table></figure><h3 id="文件间距"><a href="# 文件间距" class="headerlink" title="文件间距"></a>文件间距 </h3><p> 双倍行距</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed G</span></span><br></pre></td></tr></table></figure><p>删除所有空行和双空格</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/^$/d;G&#x27;</span></span></span><br></pre></td></tr></table></figure><p>三倍空间文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;G;G&#x27;</span></span></span><br></pre></td></tr></table></figure><p>撤消双倍行距</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;n;d&#x27;</span></span></span><br></pre></td></tr></table></figure><p>在匹配“正则表达式”的行上方插入一个空行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/regex/&#123;x;p;x;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><p>在匹配“正则表达式”的行下方插入一个空行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/regex/G&#x27;</span></span></span><br></pre></td></tr></table></figure><p>在匹配“正则表达式”的行周围插入一个空行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sed <span class="string">&#x27;/regex/&#123;x;p;x;G;&#125;&#x27;</span></span></span><br></pre></td></tr></table></figure><h2 id="另见"><a href="# 另见" class="headerlink" title="另见"></a>另见</h2><ul><li><a href="https://gist.github.com/ssstonebraker/6140154">sed 备忘单</a> <em>(gist.github.com)</em></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> sed </tag>
            
            <tag> linix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Xpath 轴，函数，谓语笔记</title>
      <link href="/posts/2873/"/>
      <url>/posts/2873/</url>
      
        <content type="html"><![CDATA[<h2 id="函数"><a href="# 函数" class="headerlink" title="函数"></a> 函数 </h2><table><thead><tr><th> 函数 </th><th> 例子 </th><th> 解释 </th></tr></thead><tbody><tr><td>starts-with</td><td>&#x2F;&#x2F;div[starts-with(@id,”maida”)]</td><td> 选取 id 值为 maida 开头的 div</td></tr><tr><td>contains</td><td>&#x2F;&#x2F;div[contains(@id,”maida”)]</td><td> 选取 id 值含 maida 的 div</td></tr><tr><td>and</td><td>&#x2F;&#x2F;div[starts-with(@id,”maida”) and contains(@id,”hello”)]</td><td> 选取 id 值为 maida 开头且含有 hello 的 div</td></tr><tr><td>text()</td><td>1. &#x2F;&#x2F;p&#x2F;text() 2. div[contains(text(),”maida”)]</td><td>1. 获取 p 的文本内容 2. 选取文本内容含 maida 的 div</td></tr><tr><td>string</td><td>1. string(.) 2. string(&#x2F;&#x2F;div&#x2F;a)</td><td>1. 获取当前节点的文本内容组合成的单独字符串 2. 获取 &#x2F;&#x2F;div&#x2F;a 匹配到的首个节点的文本内容组成的单独字符串 </td></tr></tbody></table><hr><h2 id="轴"><a href="# 轴" class="headerlink" title="轴"></a> 轴 </h2><table><thead><tr><th> 轴名 </th><th> 语法 </th><th> 解释 </th></tr></thead><tbody><tr><td>ancestor</td><td>.&#x2F;ancestor::*</td><td> 选取当前节点的所有先辈节点（父、祖父）</td></tr><tr><td>ancestor-or-self</td><td>.&#x2F;ancestor-or-self::*</td><td> 选取当前节点的所有先辈节点以及节点本身 </td></tr><tr><td>descendant</td><td>.&#x2F;descendant::*</td><td> 返回当前节点的所有后代节点（子节点、孙节点）</td></tr><tr><td>child</td><td>.&#x2F;child::*</td><td> 返回当前节点的所有子节点 </td></tr><tr><td>parent</td><td>.&#x2F;parent::*</td><td> 选取当前节点的父节点 </td></tr><tr><td>following</td><td>.&#x2F;following::*</td><td> 选取文档中当前节点结束标签后的所有节点 </td></tr><tr><td>following-sibling</td><td>.&#x2F;following-sibling::*</td><td> 选取当前节点之后的兄弟节点 </td></tr><tr><td>preceding</td><td>.&#x2F;preceding::*</td><td> 选取文档中当前节点开始标签前的所有节点 </td></tr><tr><td>preceding-sibling</td><td>.&#x2F;preceding-sibling::*</td><td> 选取当前节点之前的兄弟节点 </td></tr><tr><td>self</td><td>.&#x2F;self::*</td><td> 选取当前节点 </td></tr><tr><td>attribute</td><td>.&#x2F;attribute::*</td><td> 选取当前节点的所有属性 </td></tr></tbody></table><hr><h2 id="谓语"><a href="# 谓语" class="headerlink" title="谓语"></a> 谓语 </h2><table><thead><tr><th> 表达式 </th><th> 例子 </th><th> 解释 </th></tr></thead><tbody><tr><td>&#x2F;<em>&#x2F;</em>[num]</td><td>&#x2F;&#x2F;div&#x2F;a[1]</td><td> 选取 div 下的第一个 a</td></tr><tr><td>&#x2F;<em>&#x2F;</em>[last()]</td><td>&#x2F;&#x2F;div&#x2F;a[last()]</td><td> 选取 div 下的最后一个 a</td></tr><tr><td>&#x2F;<em>&#x2F;</em>[last()-1]</td><td>&#x2F;&#x2F;div&#x2F;a[last()-1]</td><td> 选取 div 下的倒数第二个 a</td></tr><tr><td>&#x2F;<em>&#x2F;</em>[position()&lt;3]</td><td>&#x2F;&#x2F;div&#x2F;a[position()&lt;3]</td><td> 选取 div 下的前两个 a</td></tr><tr><td>&#x2F;&#x2F;*[@maida]</td><td>&#x2F;&#x2F;div[@maida]</td><td> 选取拥有 maida 属性的 div</td></tr><tr><td>&#x2F;&#x2F;*[@id&#x3D;”maida”]</td><td>&#x2F;&#x2F;div[@id&#x3D;”maida”]</td><td> 选取拥有 id 属性等于 maida 的 div</td></tr><tr><td>&#x2F;&#x2F;*[@maida&gt;num]</td><td>&#x2F;&#x2F;div[@maida&gt;20]</td><td> 选取拥有 maida 属性大于 20 的 div</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> xpath </tag>
            
            <tag> 自动化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Xpath 定位元素</title>
      <link href="/posts/13963/"/>
      <url>/posts/13963/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是 -Xpath"><a href="# 什么是 -Xpath" class="headerlink" title="什么是 Xpath"></a>什么是 Xpath</h2><p>XPath (XML Path Language) 是一门在 XML 文档中查找信息的语言，可用来在 XML 文档中对元素和属性进行遍历。</p><p>XPath 定位在爬虫和自动化测试中都比较常用，通过使用路径表达式来选取 XML 文档中的节点或者节点集，熟练掌握 XPath 可以极大提高提取数据的效率。</p><p>因为 XPath 解析数据，是基于元素（Element）的树形结构，所以学习 XPath 前，先了解一下 html 的结构及常用标签。</p><h3 id="基本标签"><a href="# 基本标签" class="headerlink" title="基本标签"></a>基本标签 </h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> 标题：`&lt;h1&gt;、&lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt;、&lt;h5&gt;、&lt;h6&gt;、&lt;title&gt;`</span><br><span class="line"></span><br><span class="line">段落：&lt;p&gt;</span><br><span class="line"></span><br><span class="line">链接：&lt;a&gt;</span><br><span class="line"></span><br><span class="line">图像：&lt;img&gt;</span><br><span class="line"></span><br><span class="line">样式：&lt;style&gt;</span><br><span class="line"></span><br><span class="line">列表：` 无序列表 &lt;ul&gt;、有序列表 &lt;ol&gt;、列表项 &lt;li&gt;`</span><br><span class="line"></span><br><span class="line">块：`&lt;div&gt;、&lt;span&gt;`</span><br><span class="line"></span><br><span class="line">脚本：&lt;script&gt;</span><br><span class="line"></span><br><span class="line">注释：&lt;!-- 注释 --&gt;</span><br></pre></td></tr></table></figure><h2 id="XPath- 表达式学习"><a href="#XPath- 表达式学习" class="headerlink" title="XPath 表达式学习"></a>XPath 表达式学习 </h2><h3 id="常用表达式"><a href="# 常用表达式" class="headerlink" title="常用表达式"></a> 常用表达式</h3><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取次节点的所有子节点</td></tr><tr><td>&#x2F;</td><td>从根节点开始选取，绝对定位</td></tr><tr><td>&#x2F;&#x2F;</td><td>从符合条件的元素开始，不考虑他们的位置，相对定位</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>通过属性选取</td></tr></tbody></table><h3 id="XPath- 常用的定位方式："><a href="#XPath- 常用的定位方式：" class="headerlink" title="XPath 常用的定位方式："></a><strong>XPath 常用的定位方式：</strong></h3><p><strong>1. 元素属性，快速定位，唯一属性：</strong> <code>//*[@id=&quot;images&quot;]</code></p><p><strong>2. 层级与属性结合，解决没有属性问题：</strong><code>//div[@id=&quot;images&quot;]/a[1]</code></p><p><strong>3. 属性与逻辑结合，解决多个属性重名问题：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//*[@id=&quot;su&quot; and @class=&quot;bg s_btn&quot;]</span><br></pre></td></tr></table></figure><blockquote><p>注意，表达式里的下标是从 1 开始的。<br>绝对定位以 &#x2F; 开头，依赖页面的元素的顺序和位置，相对定位以 &#x2F;&#x2F; 开头，不依赖页面元素顺序和位置，根据条件进行匹配，优先使用相对定位。</p></blockquote><p>学习 XPath 本质就是掌握各种表达式的技巧，除了上述说到方法外，还有一些特别的定位方式：</p><p><strong>4. 查找 id 属性的值包含”kw”的元素：</strong> <code>//*[contains(@id,&#39;kw&#39;)]</code></p><p><strong>5. 查找⽂本⾥包含”新闻”的元素</strong>： <code>//*[contains(text(),&#39; 新闻 &#39;)]</code></p><p><strong>6. 查找 class 属性中开始位置包含’s_form_wrapper’关键字的元素：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//*[starts-with(@class,&#x27;s_form_wrapper&#x27;)]</span><br></pre></td></tr></table></figure><p><strong>7. 使⽤多个相对路径去定位⼀个元素⽤&#x2F;&#x2F; 分开:</strong></p><p>&#x2F;&#x2F;div[@class&#x3D;‘formgroup’]&#x2F;&#x2F;input[@id&#x3D;‘user-message’]</p><p><strong>8. 轴定位：</strong></p><p><strong>轴定位，使用:: 表示</strong></p><p><img src="https://pic1.zhimg.com/80/v2-02be5b84b984ed95b4e6ad7176f764a0_720w.webp" alt="img"></p><p>查找 id&#x3D;”head”元素后⾯标签名为 input 的第一个元素</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">//*[@id=&quot;head&quot;]//following::input[1]</span><br></pre></td></tr></table></figure><p><img src="https://pic4.zhimg.com/80/v2-8b973b9d5f348fa91786992f51493493_720w.webp" alt="img"></p><h3 id="如何在浏览器中查找和验证 -XPath？"><a href="# 如何在浏览器中查找和验证 -XPath？" class="headerlink" title="如何在浏览器中查找和验证 XPath？"></a>如何在浏览器中查找和验证 XPath？</h3><p><strong>1. 使用 Chrome 浏览器的开发者工具，可以快速获取 XPath 表达式：</strong></p><p>点击选择光标，选择页面上的元素位置，在控制台右键选择 Copy XPath，表达式就复制到粘贴板中了。</p><p><img src="https://pic4.zhimg.com/80/v2-dd4d1978ebdd58be9e6aed4d6648e1f7_720w.webp" alt="img"></p><p>获取到的 XPath 路径：<code>//*[@id=&quot;su&quot;]</code></p><p>获取 full XPath：<code>/html/body/div[1]/div[1]/div[5]/div/div/form/span[2]/input</code></p><p><strong>2. 验证表达式：</strong></p><p>按键“Ctrl+F”，在控制台中输入需要检查的 XPath 路径，对应的元素会有的颜色标识。</p><p><img src="https://pic4.zhimg.com/80/v2-22469ede5655087fc12d4b081d7b1413_720w.webp" alt="img"></p><h2 id="参考"><a href="# 参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/342903085">一文搞懂 XPath 定位 - 知乎 (zhihu.com)</a></li><li><a href="https://testerhome.com/topics/20296">XPATH 定位最全总结 · TesterHome</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> xpath </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>禁用 vim 的 visual 模式</title>
      <link href="/posts/29561/"/>
      <url>/posts/29561/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 从 Debian9 开始，为了便于选取文本，VIM 引入了可视 (Visual) 模式。 可以使用以下三种模式：</p><ul><li>用 v 命令进入的字符可视化模式（Characterwise visual mode)。文本选择是以字符为单位的。</li><li>用 V 命令进入的行可视化模式（Linewise visual mode)。文本选择是以行为单位的。</li><li>用 ctrl-V 进入的块可视化模式（Blockwise visual mode）。可以选择一个矩形内的文本。</li></ul><p>个人用不太习惯，此处记录一下如何 disable 这个功能。</p><h2 id="方法"><a href="# 方法" class="headerlink" title="方法"></a>方法 </h2><p> 通过编辑 vim 配置文件去除默认设置的鼠标模式<code>a</code>。可以编辑全局 <code>/etc/vim/vimrc.local</code> 或者当前用户配置文件<code>~/.vimrc</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tee</span> /etc/vim/vimrc.local  &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">source $(find / -name defaults.vim)</span></span><br><span class="line"><span class="string">let skip_defaults_vim = 1</span></span><br><span class="line"><span class="string">if has(&#x27;mouse&#x27;)</span></span><br><span class="line"><span class="string">    set mouse-=a</span></span><br><span class="line"><span class="string">endif</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p><strong>此处也记录一下 EOF 里对于变量的处理</strong></p><h3 id="希望解析变量，直接使用’-lt-lt-EOF’即可"><a href="# 希望解析变量，直接使用’-lt-lt-EOF’即可" class="headerlink" title="希望解析变量，直接使用’&lt;&lt; EOF’即可"></a>希望解析变量，直接使用’&lt;&lt; EOF’即可</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/vim/vimrc.local  &lt;&lt; EOF</span><br><span class="line">source $(find / -name defaults.vim)</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="不希望解析变量"><a href="# 不希望解析变量" class="headerlink" title="不希望解析变量"></a>不希望解析变量</h3><ol><li>EOF 加反斜杠，或用单引号、双引号包围 。适用变量多的情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /tmp/test.log &lt;&lt; &#x27;EOF&#x27;</span><br><span class="line">export NODE_HOME=/usr/local/node</span><br><span class="line">export PATH=$NODE_HOME/bin:$PATH</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><ol start="2"><li>加转义字符，适用于变量少的情况</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat cat &gt; /tmp/test.log &lt;&lt; EOF</span><br><span class="line">export NODE_HOME=/usr/local/node</span><br><span class="line">export PATH=\$NODE_HOME/bin:\$PATH</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些 git 笔记</title>
      <link href="/posts/59898/"/>
      <url>/posts/59898/</url>
      
        <content type="html"><![CDATA[<h2 id="Git-global-setup"><a href="#Git-global-setup" class="headerlink" title="Git global setup"></a>Git global setup</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;your.name@example.com&quot;</span><br></pre></td></tr></table></figure><h2 id="Create-a-new-repository-on-the-command-line"><a href="#Create-a-new-repository-on-the-command-line" class="headerlink" title="Create a new repository on the command line"></a>Create a new repository on the command line</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;# template&quot; &gt;&gt; README.md</span><br><span class="line">git init</span><br><span class="line">git add README.md</span><br><span class="line">git commit -m &quot;first commit&quot;</span><br><span class="line">git branch -M main</span><br><span class="line">git remote add origin git@github.com:Chasing66/template.git</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="Push-an-existing-repository-from-the-command-line"><a href="#Push-an-existing-repository-from-the-command-line" class="headerlink" title="Push an existing repository from the command line"></a>Push an existing repository from the command line</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:Chasing66/template.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><h2 id="gitconfig"><a href="#gitconfig" class="headerlink" title="gitconfig"></a>gitconfig</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[include]</span><br><span class="line">        path = /etc/git-setup/gitconfig</span><br><span class="line">[core]</span><br><span class="line">        editor = vim</span><br><span class="line">[user]</span><br><span class="line">        name = Your Name</span><br><span class="line">        email = your.name@example.com</span><br><span class="line">[merge]</span><br><span class="line">        tool = vimdiff</span><br><span class="line">[alias]</span><br><span class="line">        co = checkout</span><br><span class="line">        ci = commit</span><br><span class="line">        st = status</span><br><span class="line">        br = branch</span><br><span class="line">        hist = log --graph --format=format:\&quot;%C(red)%h%C(reset) %C(yellow)%cd%C(reset) | %s %C(green)\\[%an\\]%C(reset)%C(bold blue)%d%C(reset)\&quot; --abbrev-commit --date=short</span><br><span class="line">        root = rev-parse --show-toplevel</span><br><span class="line">        alias = !git config --list | grep ^alias</span><br><span class="line">        head = rev-list -n1 --abbrev-commit HEAD</span><br><span class="line">        l = log --stat --color --graph --pretty=format:&#x27;%C(bold red)%h%C(reset) - %C(bold green)(%cr)%C(bold blue)&lt;%an&gt;%C(reset) -%C(bold yellow)%d%C(reset) %s&#x27; --abbrev-commit</span><br><span class="line">[init]</span><br><span class="line">        defaultBranch = main</span><br><span class="line">[filter &quot;lfs&quot;]</span><br><span class="line">        clean = git-lfs clean -- %f</span><br><span class="line">        smudge = git-lfs smudge -- %f</span><br><span class="line">        process = git-lfs filter-process</span><br><span class="line">        required = true</span><br></pre></td></tr></table></figure><h2 id="Syncing-a-fork-branch-from-the-command-line"><a href="#Syncing-a-fork-branch-from-the-command-line" class="headerlink" title="Syncing a fork branch from the command line"></a>Syncing a fork branch from the command line</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">git remote add `origin-repo-alias` `origin-repo-address`</span><br><span class="line"></span><br><span class="line">git fetch `origin-repo-alias` `origin-repo-branch-name`</span><br><span class="line"></span><br><span class="line">git merge `origin-repo-alias/origin-repo-branch-name`</span><br><span class="line"></span><br><span class="line"># For example</span><br><span class="line">git fetch upstream</span><br><span class="line">git merge upstream/main</span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="Push-from-local-branch-to-remote-main"><a href="#Push-from-local-branch-to-remote-main" class="headerlink" title="Push from local branch to remote main"></a>Push from local branch to remote main</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fatal: The upstream branch of your current branch does not match</span><br><span class="line">the name of your current branch.  To push to the upstream branch</span><br><span class="line">on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin HEAD:main</span><br><span class="line"></span><br><span class="line">To push to the branch of the same name on the remote, use</span><br><span class="line"></span><br><span class="line">    git push origin HEAD</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Apche/Nginx 在 Ubuntu 22.04 上安装 RailLoop</title>
      <link href="/posts/54832/"/>
      <url>/posts/54832/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h2><p>RainLoop 是一个简单，现代，快速和开源的基于 Web 的电子邮件客户端，用 PHP 编写。</p><h3 id="Rainloop- 特性"><a href="#Rainloop- 特性" class="headerlink" title="Rainloop 特性"></a>Rainloop 特性</h3><ul><li>现代的 Web 界面，允许上传自定义主题</li><li>快速轻便</li><li>同时支持 SMTP 和 IMAP</li><li>支持多个帐户，可以从一个地方访问所有电子邮件地址。</li><li>支持双因素身份验证。</li><li>与 Facebook, Twitter, Google, and Dropbox 集成</li><li>无需数据库， 可以直接访问邮件服务器</li><li>易于安装和升级（在管理面板中一键升级）</li></ul><h3 id="Rainloop- 版本选择"><a href="#Rainloop- 版本选择" class="headerlink" title="Rainloop 版本选择"></a>Rainloop 版本选择</h3><p>Rainloop 有标准版和社区版两个版本， 本文使用社区版(免费)</p><h2 id="安装"><a href="# 安装" class="headerlink" title="安装"></a>安装 </h2><h3 id="Step-1-Install-Apache-PHP7- 或者 -Nginx-PHP7"><a href="#Step-1-Install-Apache-PHP7- 或者 -Nginx-PHP7" class="headerlink" title="Step 1: Install Apache + PHP7 或者 Nginx + PHP7"></a>Step 1: Install Apache + PHP7 或者 Nginx + PHP7</h3><h4 id="如果使用 -Apache- 和 -PHP7"><a href="# 如果使用 -Apache- 和 -PHP7" class="headerlink" title="如果使用 Apache 和 PHP7"></a> 如果使用 Apache 和 PHP7</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install apache2 php7.4 libapache2-mod-php7.4</span><br></pre></td></tr></table></figure><h4 id="如果使用 -Nginx- 和 -PHP7"><a href="# 如果使用 -Nginx- 和 -PHP7" class="headerlink" title="如果使用 Nginx 和 PHP7"></a>如果使用 Nginx 和 PHP7</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install nginx php7.4 php7.4-fpm php7.4-curl php7.4-xml</span><br></pre></td></tr></table></figure><h3 id="Step2- 下载 -Rainloop"><a href="#Step2- 下载 -Rainloop" class="headerlink" title="Step2: 下载 Rainloop"></a>Step2: 下载 Rainloop</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://www.rainloop.net/repository/webmail/rainloop-latest.zip</span><br><span class="line"><span class="built_in">mkdir</span> /var/www/rainloop</span><br><span class="line">unzip rainloop-latest.zip -d /var/www/rainloop</span><br><span class="line">sudo <span class="built_in">chown</span> www-data:www-data /var/www/rainloop/ -R</span><br></pre></td></tr></table></figure><h3 id="Step-3- 配置 -vHost"><a href="#Step-3- 配置 -vHost" class="headerlink" title="Step 3: 配置 vHost"></a>Step 3: 配置 vHost</h3><h4 id="使用 -Apache"><a href="# 使用 -Apache" class="headerlink" title="使用 Apache"></a>使用 Apache</h4><p>将 <code>mail.example.com</code> 换成你自己的域名</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">tee</span> /etc/apache2/sites-available/rainloop.conf &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&lt;VirtualHost *:80&gt;</span><br><span class="line">  ServerName mail.example.com</span><br><span class="line">  DocumentRoot <span class="string">&quot;/var/www/rainloop/&quot;</span></span><br><span class="line"></span><br><span class="line">  ErrorLog <span class="string">&quot;/var/log/apache2/rainloop_error_log&quot;</span></span><br><span class="line">  TransferLog <span class="string">&quot;/var/log/apache2/rainloop_access_log&quot;</span></span><br><span class="line"></span><br><span class="line">  &lt;Directory /&gt;</span><br><span class="line">    Options +Indexes +FollowSymLinks +ExecCGI</span><br><span class="line">    AllowOverride All</span><br><span class="line">    Order deny,allow</span><br><span class="line">    Allow from all</span><br><span class="line">    Require all granted</span><br><span class="line">  &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">  &lt;Directory /var/www/rainloop/data&gt;</span><br><span class="line">     Require all denied</span><br><span class="line">  &lt;/Directory&gt;</span><br><span class="line"></span><br><span class="line">&lt;/VirtualHost&gt;</span><br><span class="line">EOF</span><br><span class="line">sudo a2dissite 000-default</span><br><span class="line">sudo a2ensite rainloop.conf</span><br><span class="line">sudo systemctl reload apache2</span><br></pre></td></tr></table></figure><h4 id="使用 -Nginx"><a href="# 使用 -Nginx" class="headerlink" title="使用 Nginx"></a>使用 Nginx</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">tee</span> /etc/nginx/conf.d/rainloop.conf &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   listen [::]:80;</span><br><span class="line">   server_name mail.example.com;</span><br><span class="line"></span><br><span class="line">   root /var/www/rainloop;</span><br><span class="line">   index index.php index.html;</span><br><span class="line"></span><br><span class="line">   access_log /var/log/nginx/rainloop_access.log;</span><br><span class="line">   error_log /var/log/nginx/rainloop_error.log;</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">       try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   location ~ ^/(.+\.php)$ &#123;</span><br><span class="line">        try_files <span class="variable">$uri</span> =404;</span><br><span class="line">        fastcgi_pass unix:/run/php/php7.4-fpm.sock;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        include /etc/nginx/fastcgi_params;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   location ^~ /data &#123;</span><br><span class="line">       deny all;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo nginx -t</span><br><span class="line">sudo nginx -s reload</span><br></pre></td></tr></table></figure><h3 id="Step-4- 配置 -TLS-x2F-SSL- 证书"><a href="#Step-4- 配置 -TLS-x2F-SSL- 证书" class="headerlink" title="Step 4: 配置 TLS&#x2F;SSL 证书"></a>Step 4: 配置 TLS&#x2F;SSL 证书</h3><h4 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt -y install python3-certbot-apache</span><br><span class="line">certbot --apache --agree-tos --no-eff-email --email xxxxx@example.com</span><br></pre></td></tr></table></figure><h4 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install python3-certbot-nginx</span><br><span class="line">certbot --nginx --agree-tos --no-eff-email --email xxxxx@example.co</span><br></pre></td></tr></table></figure><p>如果你只打算用 cerbot</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt -y install certbot</span><br><span class="line">certbot certonly --standalone --agree-tos --no-eff-email --email xxxxx@example.com -d mail.example.com</span><br></pre></td></tr></table></figure><h4 id="证书路径"><a href="# 证书路径" class="headerlink" title="证书路径"></a>证书路径</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/letsencrypt/live/mail.example.com/fullchain.pem</span><br><span class="line">/etc/letsencrypt/livemail.example.com/privkey.pem</span><br></pre></td></tr></table></figure><h3 id="Step-5- 配置 -RainLoop-Webmail"><a href="#Step-5- 配置 -RainLoop-Webmail" class="headerlink" title="Step 5: 配置 RainLoop Webmail"></a>Step 5: 配置 RainLoop Webmail</h3><p>登录 <code>https://mail.example.com/?admin</code>, 默认用户名密码：admin&#x2F;12345</p><h3 id="相关参考"><a href="# 相关参考" class="headerlink" title="相关参考"></a>相关参考</h3><ul><li><a href="https://www.linuxbabe.com/mail-server/install-rainloop-webmail-ubuntu-20-04">How to Install RainLoop Webmail on Ubuntu 20.04 with Apache&#x2F;Nginx</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> apache </tag>
            
            <tag> certbot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git 撤销提交</title>
      <link href="/posts/52613/"/>
      <url>/posts/52613/</url>
      
        <content type="html"><![CDATA[<h2 id="未使用 -git-add- 的时候 -–- 在工作区"><a href="# 未使用 -git-add- 的时候 -–- 在工作区" class="headerlink" title="未使用 git add 的时候 – 在工作区"></a>未使用 git add 的时候 – 在工作区 </h2><h3 id="放弃修改某个文件"><a href="# 放弃修改某个文件" class="headerlink" title="放弃修改某个文件"></a> 放弃修改某个文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filepathname</span><br></pre></td></tr></table></figure><h3 id="放弃所有修改的文件"><a href="# 放弃所有修改的文件" class="headerlink" title="放弃所有修改的文件"></a>放弃所有修改的文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout .</span><br><span class="line">git restore .</span><br></pre></td></tr></table></figure><h2 id="已经使用 -git-add- 的时候 -–- 在暂存区"><a href="# 已经使用 -git-add- 的时候 -–- 在暂存区" class="headerlink" title="已经使用 git add 的时候 – 在暂存区"></a>已经使用 git add 的时候 – 在暂存区 </h2><h3 id="恢复某个文件到工作区"><a href="# 恢复某个文件到工作区" class="headerlink" title="恢复某个文件到工作区"></a> 恢复某个文件到工作区</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD filepathname</span><br></pre></td></tr></table></figure><h3 id="恢复所有文件到工作区"><a href="# 恢复所有文件到工作区" class="headerlink" title="恢复所有文件到工作区"></a>恢复所有文件到工作区</h3><p>git reset HEAD .<br>git reset</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：这里只是恢复到了工作区，如果想放弃修改的代码还需要执行步骤 1（工作区）中的操作</span><br></pre></td></tr></table></figure><h2 id="已经使用 -git-commit- 提交的了代码 -–- 在版本区 - 本地仓库"><a href="# 已经使用 -git-commit- 提交的了代码 -–- 在版本区 - 本地仓库" class="headerlink" title="已经使用 git commit 提交的了代码 – 在版本区 (本地仓库)"></a> 已经使用 git commit 提交的了代码 – 在版本区 (本地仓库)</h2><h3 id="全部撤回并回到远程仓库最新的状态 - 不保存代码修改"><a href="# 全部撤回并回到远程仓库最新的状态 - 不保存代码修改" class="headerlink" title="全部撤回并回到远程仓库最新的状态(不保存代码修改)"></a> 全部撤回并回到远程仓库最新的状态(不保存代码修改)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 回退到上一版本</span><br><span class="line">git reset --hard HEAD^</span><br><span class="line"># 指定 commit id 回退</span><br><span class="line">git reset --hard commit_id</span><br></pre></td></tr></table></figure><h3 id="拉回工作区并保存修改。只撤销 -commit- 和 -add- 保存代码修改"><a href="# 拉回工作区并保存修改。只撤销 -commit- 和 -add- 保存代码修改" class="headerlink" title="拉回工作区并保存修改。只撤销 commit 和 add(保存代码修改)"></a>拉回工作区并保存修改。只撤销 commit 和 add(保存代码修改)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --mixed HEAD^</span><br><span class="line"># 或者</span><br><span class="line">git reset HEAD^</span><br></pre></td></tr></table></figure><h3 id="撤销 -commit- 但是不撤销 -add- 保存代码修改"><a href="# 撤销 -commit- 但是不撤销 -add- 保存代码修改" class="headerlink" title="撤销 commit 但是不撤销 add(保存代码修改)"></a>撤销 commit 但是不撤销 add(保存代码修改)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --soft HEAD^</span><br></pre></td></tr></table></figure><h3 id="撤销修改并回到远程最新的版本 - 不保存代码修改"><a href="# 撤销修改并回到远程最新的版本 - 不保存代码修改" class="headerlink" title="撤销修改并回到远程最新的版本 (不保存代码修改)"></a> 撤销修改并回到远程最新的版本(不保存代码修改)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch --all</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h2 id="已经 -git-push- 到了远程分支"><a href="# 已经 -git-push- 到了远程分支" class="headerlink" title="已经 git push 到了远程分支"></a>已经 git push 到了远程分支 </h2><h3 id="回滚远程分支的最近一次提交"><a href="# 回滚远程分支的最近一次提交" class="headerlink" title="回滚远程分支的最近一次提交"></a> 回滚远程分支的最近一次提交</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git revert HEAD</span><br><span class="line">git push origin 分支名</span><br></pre></td></tr></table></figure><p>这种方式会在远程生成一个版本号</p><h3 id="强制刷新 -commit- 记录"><a href="# 强制刷新 -commit- 记录" class="headerlink" title="强制刷新 commit 记录"></a>强制刷新 commit 记录</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br><span class="line">git reset --hard commit_id</span><br><span class="line">git push origin -f</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>体验地表最强 TTS —— 微软 TTS</title>
      <link href="/posts/65201/"/>
      <url>/posts/65201/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h2><p>「微软文本转语音」Azure Text to Speech 是一个能将文字转换成真人般自然朗读的云服务，相比同类 TTS 强大之处在于，它借助 AI 神经网络技术，让合成的语音拥有媲美真人的表现力，实现人声语调与情感匹配，朗读时能表现出高兴、悲伤、新闻广播、客服、恐惧、耳语等情感。</p><p>可以说是当前我用过的最好的 TTS 工具了。不过服务是付费的，官方开放了一个免费的 <a href="https://azure.microsoft.com/zh-cn/services/cognitive-services/text-to-speech/?utm_source=iplaysoft.com&hmsr=iplaysoft.com#overview"> 在线 DEMO 演示</a>。可以让用户随便输入文字实现在线试听 （但字数有限制，且试听无法保存）。于是，高手们纷纷各显神通，给我们带来了几款如微软语音合成助手、Edge-TTS-record、微软 TTS 下载按钮脚本插件等免费工具，可以帮助你将一大段文字转换成音频导出 mp3 或录制成 wav 保存下来，用于其他地方。</p><p>本文使用的是 python 库：<a href="https://pypi.org/project/edge-tts/">edge-tts</a></p><h2 id="安装"><a href="# 安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install edge-tts</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="# 使用" class="headerlink" title="使用"></a>使用 </h2><h3 id="基本使用"><a href="# 基本使用" class="headerlink" title="基本使用"></a> 基本使用</h3><ol><li>使用<code>edge-tts</code> 命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge-tts --text <span class="string">&quot;Hello, world!&quot;</span> --write-media hello.mp3</span><br></pre></td></tr></table></figure><ol start="2"><li>使用<code>edge-playback</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge-playback --text <span class="string">&quot;Hello, world!&quot;</span></span><br></pre></td></tr></table></figure><h3 id="指定音色"><a href="# 指定音色" class="headerlink" title="指定音色"></a>指定音色 </h3><p> 可以使用<code>--list -voices</code> 查看支持的音色</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge-tts --list-voices</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">edge-tts --voice en-US-JennyNeural --text <span class="string">&quot;Hello everyone, nice to see you.&quot;</span> --write-media hello.mp3</span><br></pre></td></tr></table></figure><h3 id="改变音调、速率、音量"><a href="# 改变音调、速率、音量" class="headerlink" title="改变音调、速率、音量"></a>改变音调、速率、音量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">edge-tts --pitch=-10Hz --text <span class="string">&quot;Hello, world!&quot;</span> --write-media hello_with_pitch_down.mp3</span><br><span class="line">edge-tts --rate=0.5 --text <span class="string">&quot;Hello, world!&quot;</span> --write-media hello_with_rate_halved.mp3</span><br><span class="line">edge-tts --volume=50 --text <span class="string">&quot;Hello, world!&quot;</span> --write-media hello_with_volume_halved.mp3</span><br></pre></td></tr></table></figure><h2 id="灵感"><a href="# 灵感" class="headerlink" title="灵感"></a>灵感</h2><p>Todo: 造个轮子，用 flask 做个前端页面自用</p><h2 id="其他参考"><a href="# 其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ul><li><a href="https://github.com/kxxt/aspeak">aspeak</a></li><li><a href="https://github.com/LuckyHookin/edge-TTS-record">Edge-TTS-record</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cat 和 tee 的用法</title>
      <link href="/posts/16503/"/>
      <url>/posts/16503/</url>
      
        <content type="html"><![CDATA[<h2 id="EOF 和 -EOF 区别"><a href="#EOF 和 -EOF 区别" class="headerlink" title="EOF 和 -EOF 区别"></a><code>EOF</code>和 <code>-EOF</code> 区别 </h2><p>If the redirection operator is &lt;&lt;-, then all leading tab characters are stripped from input lines and the line containing delimiter.<br> 如果重定向的操作符是 &lt;&lt;-，那么分界符（EOF）所在行的开头部分的制表符（Tab）都将被去除。</p><h2 id="cat- 的用法"><a href="#cat- 的用法" class="headerlink" title="cat 的用法"></a>cat 的用法 </h2><h3 id="覆盖"><a href="# 覆盖" class="headerlink" title="覆盖"></a> 覆盖 </h3><p> 这里有两种格式可以使用</p><h4 id="格式一"><a href="# 格式一" class="headerlink" title="格式一"></a>格式一</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt; /root/test.txt</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">My site is www.361way.com</span></span><br><span class="line"><span class="string">My site is www.91it.org</span></span><br><span class="line"><span class="string">Test for cat and EOF</span>!</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="格式二"><a href="# 格式二" class="headerlink" title="格式二"></a>格式二</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &gt; /root/test.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">My site is www.361way.com</span></span><br><span class="line"><span class="string">My site is www.91it.org</span></span><br><span class="line"><span class="string">Test for cat and EOF</span>!</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>两种写法区别无法是要写入的文件放在中间或最后的问题，至于选哪种看个人喜好吧。</p><h3 id="追加"><a href="# 追加" class="headerlink" title="追加"></a>追加 </h3><p> 覆盖的写法基本和追加一样，不同的是单重定向号变成双重定向号。</p><h4 id="格式一 -1"><a href="# 格式一 -1" class="headerlink" title="格式一"></a>格式一</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt; <span class="string">EOF &gt;&gt; /root/test.txt</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">My site is www.361way.com</span></span><br><span class="line"><span class="string">My site is www.91it.org</span></span><br><span class="line"><span class="string">Test for cat and EOF</span>!</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h4 id="格式二 -1"><a href="# 格式二 -1" class="headerlink" title="格式二"></a>格式二</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &gt;&gt; /root/test.txt &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">Hello!</span></span><br><span class="line"><span class="string">My site is www.361way.com</span></span><br><span class="line"><span class="string">My site is www.91it.org</span></span><br><span class="line"><span class="string">Test for cat and EOF</span>!</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>需要注意的是，不论是覆盖还是追加，在涉及到变量操作时是需要进行转义的，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">cat</span> &lt;&lt;<span class="string">EOF &gt;&gt; /root/a.txt</span></span><br><span class="line"><span class="string">PATH=\$PATH:\$HOME/bin</span></span><br><span class="line"><span class="string">export ORACLE_BASE=/u01/app/oracle</span></span><br><span class="line"><span class="string">export ORACLE_HOME=\$ORACLE_BASE/10.2.0/db_1</span></span><br><span class="line"><span class="string">export ORACLE_SID=yqpt</span></span><br><span class="line"><span class="string">export PATH=\$PATH:\$ORACLE_HOME/bin</span></span><br><span class="line"><span class="string">export NLS_LANG=&quot;AMERICAN_AMERICA.AL32UTF8&quot;</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure><p>语法</p><h2 id="tee- 的用法"><a href="#tee- 的用法" class="headerlink" title="tee 的用法"></a>tee 的用法</h2><p>tee 命令相当于管道的一个 T 型接头。tee 命令从标准输入读取并同时写入标准输出和一个或多个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">STDOUT</span><br><span class="line">|</span><br><span class="line">&lt;---- STDIN</span><br><span class="line">|</span><br><span class="line">tee 命令行所指定的文件名</span><br></pre></td></tr></table></figure><h3 id="使用举例"><a href="# 使用举例" class="headerlink" title="使用举例"></a>使用举例 </h3><h4 id="写入到一个文件"><a href="# 写入到一个文件" class="headerlink" title="写入到一个文件"></a> 写入到一个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a line&quot;</span> | <span class="built_in">tee</span> file.txt</span><br></pre></td></tr></table></figure><h4 id="追加 -1"><a href="# 追加 -1" class="headerlink" title="追加"></a>追加</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a line&quot;</span> | <span class="built_in">tee</span> -a file.txt</span><br></pre></td></tr></table></figure><h4 id="写入到多个文件"><a href="# 写入到多个文件" class="headerlink" title="写入到多个文件"></a>写入到多个文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a line&quot;</span> | <span class="built_in">tee</span> file_1.txt file_2.txt file_3.txt</span><br></pre></td></tr></table></figure><h4 id="取消标准输出"><a href="# 取消标准输出" class="headerlink" title="取消标准输出"></a>取消标准输出</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;this is a another line&quot;</span>  | <span class="built_in">tee</span> -a file.txt &gt;/dev/null</span><br></pre></td></tr></table></figure><h4 id="配合 -sudo- 使用"><a href="# 配合 -sudo- 使用" class="headerlink" title="配合 sudo 使用"></a>配合 sudo 使用</h4><p>tee 命令的另一个优点是，您可以将其与 sudo 结合使用，并写入其他用户拥有的文件。要将文本追加到您没有写权限的文件中，请在 tee 之前添加 sudo：</p><h4 id="配合 -EOF- 使用"><a href="# 配合 -EOF- 使用" class="headerlink" title="配合 EOF 使用"></a>配合 EOF 使用 </h4><h5 id="不追加数据："><a href="# 不追加数据：" class="headerlink" title="不追加数据："></a> 不追加数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://4pwh0wn5.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h5 id="追加数据："><a href="# 追加数据：" class="headerlink" title="追加数据："></a>追加数据：</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">tee</span> &gt;&gt; <span class="built_in">test</span> &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://4pwh0wn5.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h3 id="参数"><a href="# 参数" class="headerlink" title="参数"></a>参数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a 或 --append 　附加到既有文件的后面，而非覆盖它．</span><br><span class="line">-i 或 --ignore-interrupts 　忽略中断信号。</span><br><span class="line">--help 　在线帮助。</span><br><span class="line">--version 　显示版本信息。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 direnv 自动加载当前文件夹环境变量</title>
      <link href="/posts/10135/"/>
      <url>/posts/10135/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h2><p>direnv 通过 hook 当前的 shell 来根据当前目录加载或卸载环境变量。</p><p>当进入项目对应目录之后，direnv 会检查当前和父目录中是否存在 .envrc 或 .env 的文件。如果文件存在并且有权限访问的话，则会将其加载到 BASH 的 shell 中，然后通过 direnv 捕获所有导出的变量，提供给当前 shell 使用。如果 .envrc 和 .env 文件同时存在的话，则将优先选择 .envrc 文件。</p><p>它支持像 Bash、ZSH、TCSH 和 FISH 这样的所有常见的 Shell 工具，允许项目特定的环境变量而不会对 ~&#x2F;.profile 文件进行混乱。direnv 是 Go 语言编写的, 被编译成一个静态可执行文件，所以速度足够快。它也是语言无关的，可以用来构建类似于 rbenv、pyenv 和 phpenv 的解决方案</p><h2 id="安装"><a href="# 安装" class="headerlink" title="安装"></a>安装 </h2><h3 id="直接安装"><a href="# 直接安装" class="headerlink" title="直接安装"></a> 直接安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install direnv -y</span><br></pre></td></tr></table></figure><h3 id="使用官方脚本"><a href="# 使用官方脚本" class="headerlink" title="使用官方脚本"></a>使用官方脚本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sfL https://direnv.net/install.sh | bash</span><br></pre></td></tr></table></figure><h2 id="Hook-shell"><a href="#Hook-shell" class="headerlink" title="Hook shell"></a>Hook shell</h2><ul><li>For Bash</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;eval &quot;\$(direnv hook bash)&quot;&#x27; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>For Zsh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo -e &#x27;eval &quot;$(direnv hook zsh)&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="# 使用" class="headerlink" title="使用"></a>使用 </h2><p> 在当前目录创建一个 <code>.envrc</code> 的文件, 写好你要添加的环境变量或者要 <code>source</code> 的命令</p><p>运行<code>direnv allow</code> 生效. 如果想要临时不生效, 可以运行<code>direnv deny .</code></p><h3 id="python- 项目"><a href="#python- 项目" class="headerlink" title="python 项目"></a>python 项目</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .envrc</span><br><span class="line">source .env/bin/activate</span><br><span class="line">unset PS1</span><br></pre></td></tr></table></figure><h3 id="docker-compose- 传参"><a href="#docker-compose- 传参" class="headerlink" title="docker-compose 传参"></a>docker-compose 传参</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">   web:</span><br><span class="line">     image: nginx</span><br><span class="line">     environment:</span><br><span class="line">     - &quot;type=$&#123;USERTYPE&#125;&quot;</span><br><span class="line">     ports:</span><br><span class="line">     - &quot;8080:80&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 部署 mariadb</title>
      <link href="/posts/54550/"/>
      <url>/posts/54550/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h2><p>docker 部署的优点不言而喻，一旦出现问题，可以删除的干干净净，完全不影响宿主机环境。而且只要宿主机资源足够，想起几个起几个，可以搭建主从节点。</p><p>这篇文章主要记录一下部署的步骤，部署过程中遇到的问题，以及如何解决。</p><h2 id="docker-compose-file"><a href="#docker-compose-file" class="headerlink" title="docker-compose file"></a>docker-compose file</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.9&quot;</span></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line">  <span class="attr">mariadb:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mariadb:latest</span></span><br><span class="line">    <span class="attr">container_name:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">command:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--character-set-server=utf8mb4&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--collation-server=utf8mb4_unicode_ci&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--max_allowed_packet=32505856&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--transaction-isolation=READ-COMMITTED&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;--binlog-format=ROW&quot;</span></span><br><span class="line">    <span class="attr">restart:</span> <span class="string">on-failure</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./data/mariadb:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">/var/run/mysqld/:/var/run/mysqld/</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="attr">MYSQL_ROOT_PASSWORD:</span> <span class="string">mariadb</span></span><br><span class="line">      <span class="attr">MYSQL_DATABASE:</span> <span class="string">mariadb</span></span><br><span class="line">      <span class="attr">MYSQL_USER:</span> <span class="string">phpcoin</span></span><br><span class="line">      <span class="attr">MYSQL_PASSWORD:</span> <span class="string">mariadb</span></span><br><span class="line">    <span class="attr">logging:</span></span><br><span class="line">      <span class="attr">options:</span></span><br><span class="line">        <span class="attr">max-size:</span> <span class="string">1m</span></span><br></pre></td></tr></table></figure><h2 id="访问 -mariadb"><a href="# 访问 -mariadb" class="headerlink" title="访问 mariadb"></a>访问 mariadb</h2><p>如果我们试图连接到 <code>localhost</code> 上的 MariaDB 服务器，客户端将绕过网络，尝试使用本地文件系统中的套接字文件连接到服务器。然而，当 MariaDB 在容器中运行时，这并不可行，因为服务器的文件系统与主机是隔离的。客户端无法访问容器中的套接字文件，所以它无法连接。</p><p>因此，默认情况下与 MariaDB 服务器的连接必须使用<code>TCP</code>，即使客户端与服务器容器运行在同一台机器上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mysql-client -y</span><br><span class="line"><span class="built_in">export</span> mariadb_host=$(docker inspect -f <span class="string">&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27;</span> mariadb)</span><br><span class="line">mysql -u root -p -h <span class="variable">$mariadb_host</span> --protocol=tcp</span><br></pre></td></tr></table></figure><p>那么如果想要和正常安装的 Mariadb 一样访问有没有什么办法呢？<br>当然是可以的，可以将 Mariadb 的 socket 映射到宿主机上了，注意这里映射到 socket 的目录即可</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - ./data/mariadb:/var/lib/mysql</span><br><span class="line">  - /var/run/mysqld/:/var/run/mysqld/</span><br></pre></td></tr></table></figure><h2 id="相关参考"><a href="# 相关参考" class="headerlink" title="相关参考"></a>相关参考</h2><ul><li><a href="https://mariadb.com/kb/en/installing-and-using-mariadb-via-docker/#connecting-to-mariadb-from-outside-the-container">Installing and Using MariaDB via Docker</a></li><li><a href="https://segmentfault.com/a/1190000040671500">MariaDB 用户和权限管理</a></li><li><a href="https://blog.51cto.com/u_15047485/4000234">Mariadb 设置允许远程链接</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> mariadb </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium 使用 cookies 经验</title>
      <link href="/posts/6610/"/>
      <url>/posts/6610/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 最近在使用 Selenium 时, 遇到的一个问题是由于使用了 <code>SSO</code> 集中鉴权, 会使用微软的<code>two-step authentication code</code>, 导致没有办法实现自动化登录。并且非常无奈的是，找了一大圈人，没有能帮忙解决的，按道理这种登录的问题应该是已经有成熟的经验和 case 了。最终只能靠自己的，打算使用 cookie 来暂时解决，先往下进行。</p><h2 id="获取 -cookies"><a href="# 获取 -cookies" class="headerlink" title="获取 cookies"></a>获取 cookies</h2><p>打算先写一个简单的函数来获取 cookies, 然后保存在本地，后续直接调用 cookies，这样就只需要一次登录就可以了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pytest</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Testloginforge</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_method</span>(<span class="params">self, method</span>):</span><br><span class="line">        self.driver = webdriver.Chrome()</span><br><span class="line">        self.driver.set_window_size(<span class="number">1536</span>, <span class="number">870</span>)</span><br><span class="line">        self.driver.get(<span class="string">&quot;https://targer_url&quot;</span>)</span><br><span class="line">        self.<span class="built_in">vars</span> = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">teardown_method</span>(<span class="params">self, method</span>):</span><br><span class="line">        self.driver.quit()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_get_login_cookies</span>(<span class="params">self</span>):</span><br><span class="line">        login_email = <span class="built_in">input</span>(<span class="string">&quot;Please input your login email: &quot;</span>)</span><br><span class="line">        self.driver.find_element(By.ID, <span class="string">&quot;email&quot;</span>).send_keys(login_email)</span><br><span class="line">        login_password = <span class="built_in">input</span>(<span class="string">&quot;Please input your password: &quot;</span>)</span><br><span class="line">        self.driver.find_element(By.ID, <span class="string">&quot;i0118&quot;</span>).send_keys(login_password)</span><br><span class="line">        self.driver.find_element(By.ID, <span class="string">&quot;idSIButton9&quot;</span>).click()</span><br><span class="line">        two_step_code = <span class="built_in">input</span>(<span class="string">&quot;Please input your 2-step code: &quot;</span>)</span><br><span class="line">        self.driver.find_element(</span><br><span class="line">            By.ID, <span class="string">&quot;idTxtBx_SAOTCC_OTC&quot;</span>).send_keys(two_step_code)</span><br><span class="line">        self.driver.find_element(By.CSS_SELECTOR, <span class="string">&quot;.button-text&quot;</span>).click()</span><br><span class="line">        <span class="comment"># 由于会存在二次重定向，所以需要重新访问一下目标地址</span></span><br><span class="line">        self.driver.get(<span class="string">&quot;https://targer_url&quot;</span>)</span><br><span class="line">        current_cookies = self.driver.get_cookies()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cookies.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            json.dump(current_cookies, f)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pytest.main([<span class="string">&quot;-s&quot;</span>, __file__])</span><br></pre></td></tr></table></figure><h2 id="使用 -cookies- 登录"><a href="# 使用 -cookies- 登录" class="headerlink" title="使用 cookies 登录"></a>使用 cookies 登录</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test_login_with_cookies</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cookies.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        cookies = json.load(f)</span><br><span class="line">    <span class="keyword">for</span> cookie <span class="keyword">in</span> cookies:</span><br><span class="line">        self.driver.add_cookie(cookie)</span><br><span class="line">    self.driver.get(<span class="string">&quot;https://targer_url&quot;</span>)</span><br><span class="line">    current_cookies = self.driver.get_cookies()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;cookies.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        json.dump(current_cookies, f)</span><br></pre></td></tr></table></figure><p>这里遇到的一个问题是，一开始直接先加载了 cookies，然后就报错了 <code>selenium.common.exceptions.InvalidCookieDomainException: Message: invalid cookie domain</code>, 搜索了一下发现是，默认 selenium 驱动 chrome 打开的域名为 data 的白页面，所以使用 cookies 之前需要先访问一下目标地址，可以看到在<code>setup_method</code> 里一定修改每次都优先打开目标地址，然后再加载 cookies。</p><p>相关参考：<a href="https://www.cnblogs.com/deliaries/p/14121204.html">invalid cookie domain</a></p><h2 id="后记"><a href="# 后记" class="headerlink" title="后记"></a>后记 </h2><p> 最近肯定会和 selenium 打很多交道，可以好好学习记录一下，整理一下个人的笔记，毕竟好记性不如烂笔头。</p>]]></content>
      
      
      <categories>
          
          <category> Selenium </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 pyenv 管理 python 版本</title>
      <link href="/posts/4296/"/>
      <url>/posts/4296/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 安装不同的 Python 版本并不是一件容易的事情，在不同的 Python 版本之间来回切换更加困难，而且， 多版本并存非常容易互相干扰。这里使用的 Pyenv，它能够进行全局的 Python 版本切换，也可以为单个项目提供对应的 Python 版本, 非常方便。</p><h2 id="安装步骤"><a href="# 安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><ol><li>安装编译 python 所需要的环境</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update; sudo apt-get install make build-essential libssl-dev zlib1g-dev \</span><br><span class="line">libbz2-dev libreadline-dev libsqlite3-dev wget curl llvm \</span><br><span class="line">libncursesw5-dev xz-utils tk-dev libxml2-dev libxmlsec1-dev libffi-dev liblzma-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>安装 pyenv</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://pyenv.run | bash</span><br></pre></td></tr></table></figure><ol start="3"><li>配置 pyenv</li></ol><ul><li>如果使用的是 bash</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;eval &quot;$(pyenv init -)&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure><ul><li>如果使用的是 zsh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;export PYENV_ROOT=&quot;$HOME/.pyenv&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">echo &#x27;command -v pyenv &gt;/dev/null || export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;&#x27; &gt;&gt; ~/.zshrc</span><br><span class="line">echo &#x27;eval &quot;$(pyenv init -)&quot;&#x27; &gt;&gt; ~/.zshrc</span><br></pre></td></tr></table></figure><p>重启 SHELL 生效</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">exec</span> <span class="string">&quot;<span class="variable">$SHELL</span>&quot;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>安装 python 版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.8.2</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="# 使用" class="headerlink" title="使用"></a>使用</h2><ol><li>设定全局 python 版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv global 3.8.2</span><br></pre></td></tr></table></figure><ol start="2"><li>设定所在项目的 python 版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> 3.8.2</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XiaoMi8 刷机体验 Pixel Experience 12 plus</title>
      <link href="/posts/13861/"/>
      <url>/posts/13861/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 我的小米 8 已经用了有 4 年了，当年买的时候真的是神机。只是一路用过来从 MIUI9 到 MIUI12，随着系统添加的功能越来越多，手机变得越来越卡，越来越发热，此处点名批评 MIUI 12.5.2 是真的烂。</p><p>于是萌生了体验原生安卓的想法，一番搜索了解后最终选择了 <a href="https://download.pixelexperience.org/dipper">Pixel Experience</a></p><h2 id="注意事项"><a href="# 注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>刷机会清空所有数据，注意做好备份</li><li>刷机有风险，请谨慎操作</li></ul><h2 id="准备工作"><a href="# 准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>解锁 Bootloader，登出小米账户</li><li>准备刷机工具 platform_tools</li><li>耐心和解决问题的决心</li></ul><h2 id="资源下载"><a href="# 资源下载" class="headerlink" title="资源下载"></a>资源下载 </h2><p> 为方便国内使用，所用到的镜像, recovery，以及 Magisk 都打包一起分享了，请投币自取。</p><p><a href="https://nginx.idmu.ml/XiaoMi8">Pixel Experience 12 Plus 刷机资源</a></p><h2 id="刷机步骤"><a href="# 刷机步骤" class="headerlink" title="刷机步骤"></a>刷机步骤 </h2><h3 id="输入 -PE- 官方 -recovery"><a href="# 输入 -PE- 官方 -recovery" class="headerlink" title="输入 PE 官方 recovery"></a> 输入 PE 官方 recovery</h3><p><strong>PE 12 Plus 需要使用官方的 recovery</strong></p><ol><li>手机长按 电源 + 音量下 键进入 fastboot 模式</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastboot flash recovery PixelExperience_Plus_dipper-12.1-20220722-2201-OFFICIAL.img</span><br></pre></td></tr></table></figure><ol start="2"><li>刷入成功后长按 电源 + 音量上 键进入官方 recovery</li><li>进入 recovery 后，选择<code>Factory reset</code>, 然后 <code>Format data/factory reset</code>, <code>Format cache partition</code>, <code>Format system partition</code></li></ol><h3 id="刷入 -PE-12-Plus- 镜像"><a href="# 刷入 -PE-12-Plus- 镜像" class="headerlink" title="刷入 PE 12 Plus 镜像"></a>刷入 PE 12 Plus 镜像</h3><ol><li>在 recovery 中选择<code>Apply update</code>, 再选择<code>Apply from ADB</code>, 然后回到电脑打开 CMD，使用 adb sideload 输入镜像</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload PixelExperience_Plus_dipper-12.1-20220722-2201-OFFICIAL.zip</span><br></pre></td></tr></table></figure><h3 id="刷入 -Magisk"><a href="# 刷入 -Magisk" class="headerlink" title="刷入 Magisk"></a>刷入 Magisk</h3><p>同样使用 adb sideload</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb sideload Magisk-v25.2.zip</span><br></pre></td></tr></table></figure><h2 id="结语"><a href="# 结语" class="headerlink" title="结语"></a>结语 </h2><p> 类原生安卓的最大优势就是无与伦比的流畅，Pixel Experience 12 Plus 的则是更多了一些动画，体验起来更佳，且发热更小。</p><p>当然缺点是如果不能全程挂梯子比如 clash，可能会一直唤醒 Google 后台耗电，需要自行优化。</p><p>最后补充说一句个人观点，虽然大家总是在调侃，<strong>愿你刷机半生，归来仍是 MIUI</strong>，但我希望这些不断 <strong> 花时间和精力去折腾搞机的过程应该是一种乐趣，而不是一种逃离</strong>，逃离越来越臃肿的系统，逃离越来越差的体验，最后迫于无奈才又回到 MIUI。</p><p>个人已经使用 Pixel Experience 12 plus 3 个多月了，确实有些不适应的地方，只是一与 MIUI 相比，反而觉得完全可以接受，希望 MIUI 越来越好吧</p><p>至此，Pixel Experience 12 Plus 刷机成功，完结撒花~</p>]]></content>
      
      
      
        <tags>
            
            <tag> xiaomi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ubuntu 使用 snap 包</title>
      <link href="/posts/51797/"/>
      <url>/posts/51797/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="# 概述" class="headerlink" title="概述"></a>概述 </h3><p> 什么是 snap，snap 是一种全新的软件包管理方式，它类似一个容器拥有一个应用程序所有的文件和库，各个应用程序之间完全独立。所以使用 snap 包的好处就是它解决了应用程序之间的依赖问题，使应用程序之间更容易管理。但是由此带来的问题就是它占用更多的磁盘空间<br>snap 软件包一般安装在 &#x2F;snap 目录下</p><h3 id="常用的命令"><a href="# 常用的命令" class="headerlink" title="常用的命令"></a>常用的命令 </h3><p> 其实使用 snap 包很简单，下面来介绍一下一些常用的命令</p><ul><li><code>sudo snap list</code><br>列出已经安装的 snap 包</li><li><code>sudo snap find &lt;text to search&gt;</code><br>搜索要安装的 snap 包</li><li><code>sudo snap install &lt;snap name&gt;</code><br>安装一个 snap 包</li><li><code>sudo snap refresh &lt;snap name&gt;</code><br>更新一个 snap 包，如果你后面不加包的名字的话那就是更新所有的 snap 包</li><li><code>sudo snap revert &lt;snap name&gt;</code><br>把一个包还原到以前安装的版本</li><li><code>sudo snap remove &lt;snap name&gt;</code><br>删除一个 snap 包</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu22.04 安装配置 VNC</title>
      <link href="/posts/8931/"/>
      <url>/posts/8931/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 虚拟网络计算 (VNC) 是一个图形桌面共享系统，允许您使用键盘和鼠标远程控制另一台计算机。它是 Microsoft 远程桌面 协议 (RDP)的开源替代方案。</p><h2 id="安装桌面环境"><a href="# 安装桌面环境" class="headerlink" title="安装桌面环境"></a>安装桌面环境</h2><p>Ubuntu 服务器是从命令行管理的，默认情况下没有安装桌面环境。如果您运行的是桌面版 Ubuntu，请跳过此步骤。<br>Ubuntu 存储库中有各种可用的桌面环境。一种选择是安装 Gnome，这是 Ubuntu 20.04 中的默认桌面环境。另一种选择是安装 Xfce 。它是一个快速、稳定和轻量级的桌面环境，非常适合在远程服务器上使用。</p><p>在本指南中，我们将安装 Xfce。以具有 sudo 权限的用户身份输入以下命令 ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install xfce4 xfce4-goodies</span><br></pre></td></tr></table></figure><h2 id="安装 -VNC-Server"><a href="# 安装 -VNC-Server" class="headerlink" title="安装 VNC Server"></a>安装 VNC Server</h2><p>Ubuntu 存储库中有几种不同的 VNC 服务器可用，例如 TightVNC 、TigerVNC 和 x11vnc 。每个 VNC 服务器在速度和安全性方面都有不同的优势和劣势。</p><p>我们将安装 TigerVNC。它是一个积极维护的高性能 VNC 服务器。键入以下命令以安装软件包：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install tigervnc-standalone-server</span><br></pre></td></tr></table></figure><h2 id="配置 -VNC-Server"><a href="# 配置 -VNC-Server" class="headerlink" title="配置 VNC Server"></a>配置 VNC Server</h2><h3 id="设置 -VNC-Server- 密码"><a href="# 设置 -VNC-Server- 密码" class="headerlink" title="设置 VNC Server 密码"></a>设置 VNC Server 密码 </h3><p> 使用 vncpasswd 命令设置用户密码。运行以下命令时不要使用 sudo：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vncpasswd</span><br></pre></td></tr></table></figure><p>系统将提示您输入并确认密码以及是否将其设置为仅查看密码。如果您选择设置仅查看密码，用户将无法使用鼠标和键盘与 VNC 实例交互。</p><p>Password:<br>Verify:<br>Would you like to enter a view-only password (y&#x2F;n)? n<br>密码文件存储在~&#x2F;.vnc 目录中，如果不存在则创建该目录</p><h3 id="修改 -xstartup- 文件"><a href="# 修改 -xstartup- 文件" class="headerlink" title="修改 xstartup 文件"></a>修改 xstartup 文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; ~/.vnc/xstartup &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/sh</span></span><br><span class="line"><span class="string">unset SESSION_MANAGER</span></span><br><span class="line"><span class="string">unset DBUS_SESSION_BUS_ADDRESS</span></span><br><span class="line"><span class="string">exec startxfce4</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"><span class="built_in">chmod</span> +x ~/.vnc/xstartup</span><br></pre></td></tr></table></figure><h2 id="设置 -VNC-Server- 的开机启动"><a href="# 设置 -VNC-Server- 的开机启动" class="headerlink" title="设置 VNC Server 的开机启动"></a>设置 VNC Server 的开机启动</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> &gt; /etc/systemd/system/vncserver@.service &lt;&lt; <span class="string">EOF</span></span><br><span class="line"><span class="string">[Unit]</span></span><br><span class="line"><span class="string">Description=Remote desktop service (VNC)</span></span><br><span class="line"><span class="string">After=syslog.target network.target</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Service]</span></span><br><span class="line"><span class="string">Type=simple</span></span><br><span class="line"><span class="string">PAMName=login</span></span><br><span class="line"><span class="string">User=$USER</span></span><br><span class="line"><span class="string">PIDFile=/home/%u/.vnc/%H%i.pid</span></span><br><span class="line"><span class="string">ExecStartPre=/bin/sh -c &#x27;/usr/bin/vncserver -kill :%i &gt; /dev/null 2&gt;&amp;1 || :&#x27;</span></span><br><span class="line"><span class="string">ExecStart=/usr/bin/vncserver :%i -geometry 1920x1080 --localhost no -alwaysshared -fg</span></span><br><span class="line"><span class="string">ExecStop=/usr/bin/vncserver -kill :%i</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[Install]</span></span><br><span class="line"><span class="string">WantedBy=multi-user.target</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl <span class="built_in">enable</span> vncserver@1.service</span><br><span class="line">sudo systemctl start vncserver@1.service</span><br></pre></td></tr></table></figure><p>说明： 符号 <code>1</code> 后面的数字 <code>@</code> 定义了 <code>VNC</code> 服务将在其上运行的显示端口。这意味着 <code>VNC</code> 服务器将侦听端口<code>5901</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> vnc </tag>
            
            <tag> xfce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pip 设置国内源，加快下载速度</title>
      <link href="/posts/24792/"/>
      <url>/posts/24792/</url>
      
        <content type="html"><![CDATA[<h2 id="可用国内源"><a href="# 可用国内源" class="headerlink" title="可用国内源"></a>可用国内源 </h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 清华：https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"></span><br><span class="line">阿里云：http://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/</span><br><span class="line"></span><br><span class="line">华中理工大学：http://pypi.hustunique.com/</span><br><span class="line"></span><br><span class="line">山东理工大学：http://pypi.sdutlinux.org/</span><br><span class="line"></span><br><span class="line">豆瓣：http://pypi.douban.com/simple/</span><br></pre></td></tr></table></figure><h2 id="临时使用"><a href="# 临时使用" class="headerlink" title="临时使用"></a>临时使用 </h2><p> 使用时通过加参数 <code>-i &lt;url&gt;</code> 指定源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i http://pypi.douban.com/simple/ -U pip</span><br></pre></td></tr></table></figure><h2 id="修改默认源，长期生效"><a href="# 修改默认源，长期生效" class="headerlink" title="修改默认源，长期生效"></a>修改默认源，长期生效 </h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p> 修改 ~&#x2F;.pip&#x2F;pip.conf</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>添加并修改 <code>C:\Users\$&#123;username&#125;\pip\pip.ini</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> pip </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux supervisord 基本使用</title>
      <link href="/posts/5814/"/>
      <url>/posts/5814/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h2><p>supervisord 是用 Python 开发的一个进程管理工具</p><h2 id="安装"><a href="# 安装" class="headerlink" title="安装"></a>安装 </h2><h3 id="直接使用 -pip- 直接安装"><a href="# 直接使用 -pip- 直接安装" class="headerlink" title="直接使用 pip 直接安装"></a> 直接使用 pip 直接安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install supervisor</span><br></pre></td></tr></table></figure><h3 id="使用 -apt-get- 安装"><a href="# 使用 -apt-get- 安装" class="headerlink" title="使用 apt-get 安装"></a>使用 apt-get 安装</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install supervisor</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="# 配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>supervisor 也有一个配置文件优先路径，<code>$CWD/supervisord.conf</code> &gt; <code>$CWD/etc/supervisord.conf</code> &gt; <code>/etc/supervisord.conf</code></p><p>一般会创建一个 <code>/etc/supervisord.conf</code>，然后创建一个<code>/etc/supervisor/SomeService.conf</code>, 然后在<code>/etc/supervisord.conf</code> 中包含后者</p><h3 id="生成配置文件"><a href="# 生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo_supervisord_conf &gt; /etc/supervisord.conf</span><br></pre></td></tr></table></figure><p>最后一行添加配置，方便管理自定义进程</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisor/*.conf</span><br></pre></td></tr></table></figure><h2 id="创建自定义脚本文件"><a href="# 创建自定义脚本文件" class="headerlink" title="创建自定义脚本文件"></a>创建自定义脚本文件</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[program:expressbot]</span></span><br><span class="line"><span class="attr">directory</span> = /home/ExpressBot/expressbot/main.py</span><br><span class="line"><span class="attr">command</span> = /usr/bin/python /home/ExpressBot/expressbot/main.py</span><br><span class="line"><span class="attr">autostart</span> = <span class="literal">true</span> <span class="comment">; 在 supervisord 启动的时候也自动启动</span></span><br><span class="line"><span class="attr">startsecs</span> = <span class="number">5</span> <span class="comment">; 启动 5 秒后没有异常退出，就当作已经正常启动了</span></span><br><span class="line"><span class="attr">autorestart</span> = <span class="literal">true</span> <span class="comment">; 程序异常退出后自动重启</span></span><br><span class="line"><span class="attr">startretries</span> = <span class="number">3</span> <span class="comment">; 启动失败自动重试次数，默认是 3</span></span><br><span class="line"><span class="attr">user</span> = root <span class="comment">; 用哪个用户启动</span></span><br><span class="line"><span class="attr">redirect_stderr</span> = <span class="literal">true</span> <span class="comment">; 把 stderr 重定向到 stdout，默认 false</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span> = <span class="number">20</span>MB <span class="comment">; stdout 日志文件大小，默认 50MB</span></span><br><span class="line"><span class="attr">stdout_logfile_backups</span> = <span class="number">20</span> <span class="comment">; stdout 日志文件备份数</span></span><br><span class="line"><span class="attr">stdout_logfile</span> = /var/log/expressbot_stdout.log <span class="comment">; 日志文件</span></span><br></pre></td></tr></table></figure><h2 id="启动 -supervisor"><a href="# 启动 -supervisor" class="headerlink" title="启动 supervisor"></a>启动 supervisor</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">supervisord -c /etc/supervisord.conf</span><br></pre></td></tr></table></figure><h2 id="supervisorctl- 管理命令"><a href="#supervisorctl- 管理命令" class="headerlink" title="supervisorctl 管理命令"></a>supervisorctl 管理命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">supervisorctl start projectname <span class="comment"># 启动进程</span></span><br><span class="line">supervisorctl stop projectname <span class="comment"># 结束进程</span></span><br><span class="line">supervisorctl restart projectname <span class="comment"># 重启进程</span></span><br><span class="line">supervisorctl stop all <span class="comment"># 停止所有进程</span></span><br><span class="line">supervisorctl update <span class="comment"># 更新变动的进程配置</span></span><br><span class="line">supervisorctl reload <span class="comment"># 重启所有进程</span></span><br><span class="line">supervisorctl status <span class="comment"># 查看进程状态</span></span><br></pre></td></tr></table></figure><h2 id="supervisord- 模板"><a href="#supervisord- 模板" class="headerlink" title="supervisord 模板"></a>supervisord 模板</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[supervisord]</span></span><br><span class="line"><span class="attr">nodaemon</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">logfile</span>=/dev/null</span><br><span class="line"><span class="attr">logfile_maxbytes</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">user</span>=root</span><br><span class="line"></span><br><span class="line"><span class="section">[include]</span></span><br><span class="line"><span class="attr">files</span> = /etc/supervisord.d/*.conf</span><br><span class="line"></span><br><span class="line"><span class="section">[program:vncserver]</span></span><br><span class="line"><span class="attr">command</span>=/usr/bin/vncserver -localhost <span class="literal">no</span> :<span class="number">1</span> -passwd /root/.vnc/passwd -useold</span><br><span class="line"><span class="attr">directory</span>=/root</span><br><span class="line"></span><br><span class="line"><span class="section">[program:ytdl]</span></span><br><span class="line"><span class="attr">directory</span>=/ytdlbot</span><br><span class="line"><span class="attr">command</span>=python ytdl.py</span><br><span class="line"><span class="attr">autorestart</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">stdout_logfile</span>=/dev/fd/<span class="number">1</span></span><br><span class="line"><span class="attr">stdout_logfile_maxbytes</span>=<span class="number">0</span></span><br><span class="line"><span class="attr">redirect_stderr</span>=<span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> supervisord </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 配置开机自启动</title>
      <link href="/posts/7581/"/>
      <url>/posts/7581/</url>
      
        <content type="html"><![CDATA[<h2 id="systemd- 自动启动"><a href="#systemd- 自动启动" class="headerlink" title="systemd 自动启动"></a>systemd 自动启动 </h2><p> 路径: <code>/lib/systemd/system/hysteria.service</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Hysteria</span><br><span class="line">After=network.target network-online.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Restart=on-failure</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/sbin/hysteria -config /etc/hysteria/config.json server</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl daemon-reload # 重新加载</span><br><span class="line">systemctl enable hysteria # 开机自启</span><br><span class="line">systemctl start hysteria # 启动</span><br><span class="line">systemctl status hysteria # 状态</span><br></pre></td></tr></table></figure><h3 id="使用 cat 生成配置文件"><a href="# 使用 cat 生成配置文件" class="headerlink" title="使用 cat 生成配置文件"></a>使用 <code>cat</code> 生成配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cat &gt; /etc/systemd/system/onedrive.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=onedrive</span><br><span class="line">After=network-online.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/usr/bin/rclone mount onedrive: /onedrive --use-mmap --umask 000 --default-permissions --no-check-certificate --allow-other --allow-non-empty --dir-cache-time 24h --cache-dir=/home/cache --vfs-cache-mode full --buffer-size 256M --vfs-read-ahead 512M --vfs-read-chunk-size 32M --vfs-read-chunk-size-limit 128M --vfs-cache-max-size 20G --low-level-retries 200</span><br><span class="line">ExecStop=/usr/bin/fusermount -u /onedriver</span><br><span class="line">Restart=on-abort</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="OpenRC- 启动项"><a href="#OpenRC- 启动项" class="headerlink" title="OpenRC 启动项"></a>OpenRC 启动项 </h2><p> 路径: <code>/etc/init.d/hysteria</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#!/sbin/openrc-run</span><br><span class="line"></span><br><span class="line">name=&quot;hysteria&quot;</span><br><span class="line">command=&quot;/usr/sbin/hysteria&quot;</span><br><span class="line">command_args=&quot;-config /etc/hysteria/config.json server&quot;</span><br><span class="line">command_background=&quot;yes&quot;</span><br><span class="line">pidfile=&quot;/run/hysteria.pid&quot;</span><br><span class="line"></span><br><span class="line">depend() &#123;</span><br><span class="line">    after sshd</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod +x /etc/init.d/hysteria</span><br><span class="line">rc-update add hysteria # 开机自启动</span><br><span class="line">rc-service hysteria start # 启动</span><br><span class="line">service hysteria status # 查看状态</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html">Systemd 入门教程：实战篇</a></li><li><a href="http://www.jinbuguo.com/systemd/systemd.service.html">systemd.service 中文手册</a></li><li><a href="https://wiki.archlinux.org/title/systemd_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">systemd (简体中文)</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>yaml 还是 yml?</title>
      <link href="/posts/1109/"/>
      <url>/posts/1109/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p>yaml 的文件扩展名有两种：<code>.yaml</code> 和<code>.yml</code>。那么到底应该使用哪个后缀呢？</p><h2 id="官方文档"><a href="# 官方文档" class="headerlink" title="官方文档"></a>官方文档 </h2><p> 根据 <a href="http://yaml.org/">yaml.org</a> 的官方文档，推荐我们使用<code>.yaml</code>。</p><h2 id="历史原因"><a href="# 历史原因" class="headerlink" title="历史原因"></a>历史原因 </h2><p> 文件的扩展名对文件的内容没有任何关系或影响。可以在任何扩展名的文件中保存 YAML 内容：<code>.yml</code>、<code>.yaml</code>或其他任何文件。</p><p>YAML FAQ（相当少）建议使用 <code>.yaml</code> 而不是<code>.yml</code>，但由于历史原因，许多 Windows 程序员仍然害怕使用超过三个字符的扩展名，所以选择使用<code>.yml</code>。</p><p>所以，真正重要的是文件里面有什么，而不是它的扩展名是什么。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>git 自动换行符</title>
      <link href="/posts/42891/"/>
      <url>/posts/42891/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 最近在提交代码时，始终无法过 static analysis。最后发现由于使用了 BeyondCompare 比较更改配置，然后再 Window 提交的代码，提交代码时，没有检查换行符。</p><h2 id="基本概念"><a href="# 基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>回车 CR：将光标移动到当前行开头；</li><li>换行 LF：将光标“垂直”移动到下一行，并不改变光标水平位置。</li></ul><p>CR、LF、CR&#x2F;LF 为不同操作系统上使用的换行符：</p><table><thead><tr><th>平台</th><th>区别</th></tr></thead><tbody><tr><td>Windows&#x2F;DOS</td><td>采用 CR&#x2F;LF 表示下一行</td></tr><tr><td>Unix&#x2F;Linux</td><td>采用 LF 表示下一行</td></tr><tr><td>Mac OS 系统</td><td>采用 CR 表示下一行</td></tr><tr><td>Mac OS X 系统</td><td>采用 LF 表示下一行</td></tr></tbody></table><h2 id="解决方法"><a href="# 解决方法" class="headerlink" title="解决方法"></a>解决方法 </h2><h3 id="修改 -git-config-autocrlf- 配置："><a href="# 修改 -git-config-autocrlf- 配置：" class="headerlink" title="修改 git config autocrlf 配置："></a> 修改 git config autocrlf 配置：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure><p>配置有以下区别：</p><ol><li>core.autocrlf input：设置为 input，表示 git 在提交时转换为 LF，检出时不转换</li><li>core.autocrlf true：设置为 true，表示 git 在提交时转换为 LF，检出时转换为 CRLF</li><li>core.autocrlf false：设置为 false，表示提交检出均不转换</li></ol><h3 id="saftcrlf- 增强提交时的检查"><a href="#saftcrlf- 增强提交时的检查" class="headerlink" title="saftcrlf - 增强提交时的检查"></a>saftcrlf - 增强提交时的检查</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.safecrlf true</span><br></pre></td></tr></table></figure><p>配置有以下区别：</p><ol><li>core.safecrlf true：设置为 true，拒绝提交包含混合换行符的文件</li><li>core.safecrlf false：设置为 false，允许提交包含混合换行符的文件</li><li>core.safecrlf warn：设置为 warn，提交包含混合换行符的文件时给出警告</li></ol><p>Note: 尽量不要跨平台提交代码</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 使用 adduser 与 useradd 添加普通用户的正确姿势</title>
      <link href="/posts/5650/"/>
      <url>/posts/5650/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 在 Linux 操作系统中，添加用户可以使用 <code>useradd</code> 和 <code>adduser</code> 这两个命令。曾经在添加用户的实践中遇到过一些坑，比如使用 <code>useradd</code> 命令添加用户后无法正常使用，对 <code>adduser</code> 和 <code>useradd</code> 傻傻分不清楚。网上找到的相关内容很碎片化，初看会让人一脸懵逼，这促使我对这些知识进行了整理。</p><blockquote><p>本文所有指令需要在 root 权限下执行。非 root 用户需要加 <code>sudo</code> 前缀，或使用 <code>sudo -i</code> 命令切换到 root 账户操作。</p></blockquote><h2 id="adduser- 和 -useradd- 的区别"><a href="#adduser- 和 -useradd- 的区别" class="headerlink" title="adduser 和 useradd 的区别"></a>adduser 和 useradd 的区别 </h2><p> 对于 De­bian 或 Ubuntu ，主要的区别在使用方式上：</p><ul><li><code>adduser</code>是一个 perl 脚本，通过交互式菜单设定一些用户参数。在输入 <code>adduser 用户名</code> 后，会自动创建用户主目录（并复制 <code>/etc/skel</code> 目录下的文件）、指定系统 shell，提示输入用户密码，很简单的就添加了一个标准的普通用户。</li><li><code>useradd</code>是一个指令，如果不使用任何选项，创建的用户将无密码、无主目录、没有指定 shell。如果你需要正常使用这个账户，就还需要设置密码、创建家目录等额外操作。</li></ul><p>对于 Cen­tOS 来说是没有区别的，<code>adduser</code> 通过符号链接指向 <code>useradd</code>，即 Cen­tOS 只有 <code>useradd</code></p><h2 id="使用 -adduser- 添加用户"><a href="# 使用 -adduser- 添加用户" class="headerlink" title="使用 adduser 添加用户"></a>使用 adduser 添加用户 </h2><p> 以添加用户名为 <code>enwaiax</code> 的用户为例子，输入以下命令进入添加用户交互式菜单</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser enwaiax</span><br></pre></td></tr></table></figure><p>然后会提示输入密码，之后一路回车即可，非常简单。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Adding user `enwaiax&#x27; ...</span><br><span class="line">Adding new group `enwaiax&#x27; (1002) ...</span><br><span class="line">Adding new user `enwaiax&#x27; (1001) with group `enwaiax&#x27; ...</span><br><span class="line">Creating home directory `/home/enwaiax&#x27; ...</span><br><span class="line">Copying files from `/etc/skel&#x27; ...</span><br><span class="line">New password:</span><br><span class="line">Retype new password:</span><br><span class="line">passwd: password updated successfully</span><br><span class="line">Changing the user information for enwaiax</span><br><span class="line">Enter the new value, or press ENTER for the default</span><br><span class="line">        Full Name []:</span><br><span class="line">        Room Number []:</span><br><span class="line">        Work Phone []:</span><br><span class="line">        Home Phone []:</span><br><span class="line">        Other []:</span><br><span class="line">Is the information correct? [Y/n]</span><br></pre></td></tr></table></figure><h2 id="使用 -useradd- 添加用户"><a href="# 使用 -useradd- 添加用户" class="headerlink" title="使用 useradd 添加用户"></a>使用 useradd 添加用户 </h2><p> 前面提到，<code>useradd</code> 如果不使用任何选项，创建的用户将无密码、无主目录、没有指定 shell。为了和 <code>adduser</code> 一样添加一个标准的普通用户就需要指定选项，或者手动进行额外操作，这样添加的用户才能正常使用。所以对于 <code>useradd</code> 添加标准的普通用户有 <strong> 使用选项 </strong> 和<strong>不使用选项 </strong> 两种方式。</p><h3 id="使用选项"><a href="# 使用选项" class="headerlink" title="使用选项"></a>使用选项 </h3><p> 以添加用户名为 <code>enwaiax</code> 的用户为例子，输入命令添加用户、添加用户目录、指定 bash 为 shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m -s /bin/bash enwaiax</span><br></pre></td></tr></table></figure><blockquote><p><code>-m</code> 自动创建用户的家目录，并将 &#x2F;etc&#x2F;skel 中的文件复制到家目录中<br><code>-s</code> 指定用户登入后所使用的 shell</p></blockquote><p>然后对该用户设置密码，输入命令后会提示输入两次密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd enwaiax</span><br></pre></td></tr></table></figure><h3 id="不使用选项"><a href="# 不使用选项" class="headerlink" title="不使用选项"></a>不使用选项 </h3><p> 在不使用选项的情况下，添加一个标准普的通用户的过程相总共有 6 个步骤，略显麻烦，也没必要这样操作。但可以从中了解添加一个用户具体做了哪些事情，对解决一些问题有参考价值。</p><ol><li>以添加用户名为 <code>enwaiax</code> 的用户为例子，输入命令添加用户</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd enwaiax</span><br></pre></td></tr></table></figure><ol><li>设置密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd enwaiax</span><br></pre></td></tr></table></figure><ol><li>创建家目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /home/enwaiax</span><br></pre></td></tr></table></figure><ol><li>将 <code>/etc/skel</code> 目录下的文件复制到该用户目录</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -r /etc/skel/. /home/enwaiax</span><br></pre></td></tr></table></figure><ol><li>更改家目录归属</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R enwaiax:enwaiax /home/enwaiax</span><br></pre></td></tr></table></figure><ol><li>指定 Shell 为<code>/bin/bash</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /bin/bash enwaiax</span><br></pre></td></tr></table></figure><h2 id="删除用户"><a href="# 删除用户" class="headerlink" title="删除用户"></a>删除用户 </h2><p> 如果因为错误的方式添加了用户，而不知道如何解决，可以删除这个用户。</p><p>以删除 <code>enwaiax</code> 这个用户为例子，首先终结该用户所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkill -u enwaiax</span><br></pre></td></tr></table></figure><p>然后输入删除命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r enwaiax</span><br></pre></td></tr></table></figure><blockquote><p><code>-r</code> 表示删除用户的同时，将其宿主目录和系统内与其相关的内容删除。</p></blockquote><h2 id="授予普通用户 -sudo- 权限"><a href="# 授予普通用户 -sudo- 权限" class="headerlink" title="授予普通用户 sudo 权限"></a>授予普通用户 sudo 权限 </h2><p> 有时需要使用 root 权限，比如安装软件、启动服务等操作时就需要用到 <code>sudo</code> 命令来提升权限才能进行操作。而新添加的普通用户是没有权限进行 sudo 操作的，所以我们需要对普通用户授予 sudo 权限。可以参考《<a href="https://enwaiax.com/archives/linux-grants-normal-user-sudo-permission.html">Linux 中授予普通用户 sudo 权限的正确方法</a>》这篇文章来进行设置。</p><h2 id="参考文章"><a href="# 参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><p><a href="https://enwaiax.com/go/aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNzMxNjQwNg">一天一点 linux (18):adduser 和 useradd 的区别</a></p></li><li><p><a href="https://enwaiax.com/go/aHR0cHM6Ly93d3cucnVub29iLmNvbS9saW51eC9saW51eC11c2VyLW1hbmFnZS5odG1s">Linux 用户和用户组管理</a></p></li><li><p><a href="https://enwaiax.com/go/aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc3BhcmtkZXYvcC81ODIzMzUzLmh0bWw">linux useradd 命令基本用法</a></p></li></ul><blockquote><p>原文转载自<a href="https://p3terx.com/archives/add-normal-users-with-adduser-and-useradd.html">Linux 中授予普通用户 sudo 权限的正确方法 - P3TERX ZONE</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 中授予普通用户 sudo 权限的正确方法</title>
      <link href="/posts/50757/"/>
      <url>/posts/50757/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 有时需要使用 root 权限，比如安装软件、启动服务等操作时就需要用到 <code>sudo</code> 命令来提升权限才能进行操作。而新添加的普通用户是没有权限进行 sudo 操作的，所以我们需要对普通用户授予 sudo 权限。授予 sudo 权限有三个方法，第一个是把用户添加到 sudo 用户组，第二个是修改 sudo 配置文件 (<code>etc/sudoers</code>)，第三个是添加配置文件到 <code>/etc/sudoers.d/</code> 目录中。选其中一个即可，<strong>推荐第三个方法</strong>。</p><h2 id="安装 -sudo"><a href="# 安装 -sudo" class="headerlink" title="安装 sudo"></a>安装 sudo</h2><p>如果系统中没有 <code>sudo</code>，需要先安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Debian</span></span><br><span class="line">apt install sudo -y</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Centos</span></span><br><span class="line">yum install sudo -y</span><br></pre></td></tr></table></figure><h2 id="添加用户到 -sudo- 用户组"><a href="# 添加用户到 -sudo- 用户组" class="headerlink" title="添加用户到 sudo 用户组"></a>添加用户到 sudo 用户组 </h2><p> 以添加 <code>enwaiax</code> 这个用户到 sudo 用户组为例子，输入下面命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -aG sudo enwaiax</span><br></pre></td></tr></table></figure><h2 id="修改 -sudo- 配置文件 -etc-sudoers"><a href="# 修改 -sudo- 配置文件 -etc-sudoers" class="headerlink" title="修改 sudo 配置文件 (etc/sudoers)"></a> 修改 sudo 配置文件 (<code>etc/sudoers</code>)</h2><p> 打开 sudo 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">visudo</span><br></pre></td></tr></table></figure><p>以授予 <code>enwaiax</code> 这个用户 sudo 权限为例子，添加如下内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enwaiax ALL=(ALL) ALL</span><br></pre></td></tr></table></figure><h2 id="添加配置文件到 -etc-sudoers-d- 目录中"><a href="# 添加配置文件到 -etc-sudoers-d- 目录中" class="headerlink" title="添加配置文件到 /etc/sudoers.d/ 目录中"></a>添加配置文件到 <code>/etc/sudoers.d/</code> 目录中 </h2><p> 这个是系统文档推荐的做法。<code>/etc/sudoers.d/</code> 目录中的文件相当于是 <code>etc/sudoers</code> 文件的补充。如果你写的配置文件有问题或者是想去除用户的 sudo 权限，直接删除文件即可，不用去修改 <code>/etc/sudoers</code> 文件，不会影响到系统默认配置。</p><p>以授予 <code>enwaiax</code> 这个用户 sudo 权限为例子，在终端中输入以下命令直接添加配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/sudoers.d/enwaiax &lt;&lt;&lt; &#x27;enwaiax ALL=(ALL) ALL&#x27;</span><br></pre></td></tr></table></figure><h3 id="设置免密"><a href="# 设置免密" class="headerlink" title="设置免密"></a>设置免密 </h3><p> 如果你不想输入每次 <code>sudo</code> 都输入密码，可以设置免密。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tee /etc/sudoers.d/enwaiax &lt;&lt;&lt; &#x27;enwaiax ALL=(ALL) NOPASSWD: ALL&#x27;</span><br></pre></td></tr></table></figure><blockquote><p><strong>服务器不要设置免密！不安全！</strong></p></blockquote><p>最后赋予正确的权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 440 /etc/sudoers.d/enwaiax</span><br></pre></td></tr></table></figure><blockquote><p>原文转载自<a href="https://p3terx.com/archives/linux-grants-normal-user-sudo-permission.html">Linux 中授予普通用户 sudo 权限的正确方法 - P3TERX ZONE</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> sudo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结：Python 中的异常处理</title>
      <link href="/posts/15032/"/>
      <url>/posts/15032/</url>
      
        <content type="html"><![CDATA[<p>异常处理在任何一门编程语言里都是值得关注的一个话题，良好的异常处理可以让你的程序更加健壮，清晰的错误信息更能帮助你快速修复问题。在 Python 中，和不部分高级语言一样，使用了 try&#x2F;except&#x2F;finally 语句块来处理异常，如果你有其他编程语言的经验，实践起来并不难。</p><h2 id="异常处理语句 -try…excpet…finally"><a href="# 异常处理语句 -try…excpet…finally" class="headerlink" title="异常处理语句 try…excpet…finally"></a>异常处理语句 try…excpet…finally</h2><h3 id="实例代码"><a href="# 实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">div</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(a / b)</span><br><span class="line">    <span class="keyword">except</span> ZeroDivisionError:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Error: b should not be 0 !!&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Unexpected Error: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(e))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Run into else only when everything goes well&#x27;</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Always run into finally block.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># tests</span></span><br><span class="line">div(<span class="number">2</span>, <span class="number">0</span>)</span><br><span class="line">div(<span class="number">2</span>, <span class="string">&#x27;bad type&#x27;</span>)</span><br><span class="line">div(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutiple exception in one line</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(a / b)</span><br><span class="line"><span class="keyword">except</span> (ZeroDivisionError, TypeError) <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Except block is optional when there is finally</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">open</span>(database)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    close(database)</span><br><span class="line"></span><br><span class="line"><span class="comment"># catch all errors and log it</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    do_work()</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="comment"># get detail from logging module</span></span><br><span class="line">    logging.exception(<span class="string">&#x27;Exception caught!&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get detail from sys.exc_info() method</span></span><br><span class="line">    error_type, error_value, trace_back = sys.exc_info()</span><br><span class="line">    <span class="built_in">print</span>(error_value)</span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><h3 id="总结如下"><a href="# 总结如下" class="headerlink" title="总结如下"></a>总结如下</h3><ol><li><code>except</code>语句不是必须的，<code>finally</code>语句也不是必须的，但是二者必须要有一个，否则就没有 <code>try</code> 的意义了。</li><li><code>except</code>语句可以有多个，Python 会按 <code>except</code> 语句的顺序依次匹配你指定的异常，如果异常已经处理就不会再进入后面的 <code>except</code> 语句。</li><li><code>except</code>语句可以以元组形式同时指定多个异常，参见实例代码。</li><li><code>except</code>语句后面如果不指定异常类型，则默认捕获所有异常，你可以通过 logging 或者 sys 模块获取当前异常。</li><li>如果要捕获异常后要重复抛出，请使用<code>raise</code>，后面不要带任何参数或信息。</li><li>不建议捕获并抛出同一个异常，请考虑重构你的代码。</li><li>不建议在不清楚逻辑的情况下捕获所有异常，有可能你隐藏了很严重的问题。</li><li>尽量使用内置的异常处理语句来替换 <code>try/except</code> 语句，比如 <code>with</code> 语句，<code>getattr()</code>方法。</li></ol><h2 id="抛出异常 -raise"><a href="# 抛出异常 -raise" class="headerlink" title="抛出异常 raise"></a>抛出异常 raise</h2><p>如果你需要自主抛出异常一个异常，可以使用 <code>raise</code> 关键字，等同于 C# 和 Java 中的<code>throw</code>，其语法规则如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> NameError(<span class="string">&quot;bad name!&quot;</span>)</span><br></pre></td></tr></table></figure><p><code>raise</code>关键字后面可以指定你要抛出的异常实例，一般来说抛出的异常越详细越好，Python 在 <code>exceptions</code> 模块内建了很多的异常类型，通过使用 <code>dir()</code> 函数来查看 <code>exceptions</code> 中的异常类型，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> exceptions</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="built_in">dir</span>(exceptions)</span><br><span class="line"><span class="comment"># [&#x27;ArithmeticError&#x27;, &#x27;AssertionError&#x27;...]</span></span><br></pre></td></tr></table></figure><p>当然你也可以查阅 Python 的 <a href="https://docs.python.org/3/library/exceptions.html#bltin-exceptions"> 文档库 </a> 进行更详细的了解。</p><h2 id="自定义异常类型"><a href="# 自定义异常类型" class="headerlink" title="自定义异常类型"></a>自定义异常类型 </h2><p>Python 中自定义自己的异常类型非常简单，只需要要从<code>Exception</code> 类继承即可(直接或间接)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeCustomException</span>(<span class="title class_ inherited__">Exception</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AnotherException</span>(<span class="title class_ inherited__">SomeCustomException</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>一般你在自定义异常类型时，需要考虑的问题应该是这个异常所应用的场景。如果内置异常已经包括了你需要的异常，建议考虑使用内置的异常类型。比如你希望在函数参数错误时抛出一个异常，你可能并不需要定义一个 <code>InvalidArgumentError</code>，使用内置的<code>ValueError</code> 即可。</p><h2 id="经验案例"><a href="# 经验案例" class="headerlink" title="经验案例"></a>经验案例 </h2><h3 id="传递异常 -re-raise-Exception"><a href="# 传递异常 -re-raise-Exception" class="headerlink" title="传递异常 re-raise Exception"></a> 传递异常 re-raise Exception</h3><p>捕捉到了异常，但是又想重新抛出它（传递异常），使用不带参数的 <code>raise</code> 语句即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="number">1</span>/<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f1()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">raise</span>  <span class="comment"># don&#x27;t raise e !!!</span></span><br><span class="line"></span><br><span class="line">f2()</span><br></pre></td></tr></table></figure><p>在 Python2 中，为了保持异常的完整信息，那么你捕获后再次抛出时千万不能在 <code>raise</code> 后面加上异常对象，否则你的 **<code>trace</code>信息就会从此处截断 **。以上是最简单的重新抛出异常的做法，也是推荐的做法。</p><p>还有一些技巧可以考虑，比如抛出异常前你希望对异常的信息进行更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        f1()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        e.args += (<span class="string">&#x27;more info&#x27;</span>,)</span><br><span class="line">        <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>如果你有兴趣了解更多，建议阅读这篇博客。</p><ul><li><a href="https://link.segmentfault.com/?enc=fcas98K5hhdSFFTbkgV1Dw==.AKL52enEIXMkWjthE/Z8OeDh48SKu/HXJvQhHi6CzIX9D8v9XDcOVfIGDNuDxSTz/ur3Kw49h8gTwTOwTT7CpGl1faDn7C/0E8y4mXlROvY=">http://www.ianbicking.org/blo...</a></li></ul><p>Python3 对重复传递异常有所改进，你可以自己尝试一下，不过建议还是遵循以上规则。</p><h3 id="Exception- 和 -BaseException"><a href="#Exception- 和 -BaseException" class="headerlink" title="Exception 和 BaseException"></a>Exception 和 BaseException</h3><p>当我们要捕获一个通用异常时，应该用 <code>Exception</code> 还是<code>BaseException</code>？我建议你还是看一下<a href="https://link.segmentfault.com/?enc=zdhVAqe/4XjlGUFAtDdSFw==.W6egf2xS3mSqaecAhftqqQasmWctnSiakhT5p0QfYYVQst9WyOAstjAGMdf6TYMNl9nw8Sac6RMcnfOinno0K+J83/1x/VeaJmDfww7r9Nw="> 官方文档说明</a>，这两个异常到底有啥区别呢？ 请看它们之间的继承关系。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">BaseException</span><br><span class="line"> +<span class="comment">-- SystemExit</span></span><br><span class="line"> +<span class="comment">-- KeyboardInterrupt</span></span><br><span class="line"> +<span class="comment">-- GeneratorExit</span></span><br><span class="line"> +<span class="comment">-- Exception</span></span><br><span class="line">      +<span class="comment">-- StopIteration...</span></span><br><span class="line">      +<span class="comment">-- StandardError...</span></span><br><span class="line">      +<span class="comment">-- Warning...</span></span><br></pre></td></tr></table></figure><p>从 <code>Exception</code> 的层级结构来看，<code>BaseException</code>是最基础的异常类，<code>Exception</code>继承了它。<code>BaseException</code>除了包含所有的 <code>Exception</code> 外还包含了 <code>SystemExit</code>，<code>KeyboardInterrupt</code> 和<code>GeneratorExit</code>三个异常。</p><p>由此看来你的程序在捕获所有异常时更应该使用 <code>Exception</code> 而不是<code>BaseException</code>，因为被排除的三个异常属于更高级别的异常，合理的做法应该是交给 Python 的解释器处理。</p><h3 id="使用内置的语法范式代替 -try-x2F-except"><a href="# 使用内置的语法范式代替 -try-x2F-except" class="headerlink" title="使用内置的语法范式代替 try&#x2F;except"></a>使用内置的语法范式代替 try&#x2F;except</h3><p>Python 本身提供了很多的语法范式简化了异常的处理，比如 <code>for</code> 语句就处理了的 <code>StopIteration</code> 异常，让你很流畅地写出一个循环。</p><p><code>with</code>语句在打开文件后会自动调用 <code>finally</code> 并关闭文件。我们在写 Python 代码时应该尽量避免在遇到这种情况时还使用 try&#x2F;except&#x2F;finally 的思维来处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># should not</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(a_file)</span><br><span class="line">    do_something(f)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># should</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(a_file) <span class="keyword">as</span> f:</span><br><span class="line">    do_something(f)</span><br></pre></td></tr></table></figure><p>再比如，当我们需要访问一个不确定的属性时，有可能你会写出这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    test = Test()</span><br><span class="line">    name = test.name  <span class="comment"># not sure if we can get its name</span></span><br><span class="line"><span class="keyword">except</span> AttributeError:</span><br><span class="line">    name = <span class="string">&#x27;default&#x27;</span></span><br></pre></td></tr></table></figure><p>其实你可以使用更简单的 <code>getattr()</code> 来达到你的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">getattr</span>(test, <span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;default&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="最佳实践"><a href="# 最佳实践" class="headerlink" title="最佳实践"></a>最佳实践 </h2><p> 最佳实践不限于编程语言，只是一些规则和填坑后的收获。</p><ol><li>只处理你知道的异常，避免捕获所有异常然后吞掉它们。</li><li>抛出的异常应该说明原因，有时候你知道异常类型也猜不出所以然。</li><li>避免在 <code>catch</code> 语句块中干一些没意义的事情，捕获异常也是需要成本的。</li><li>不要使用异常来控制流程，那样你的程序会无比难懂和难维护。</li><li>如果有需要，切记使用 <code>finally</code> 来释放资源。</li><li>如果有需要，请不要忘记在处理异常后做清理工作或者回滚操作。</li></ol><blockquote><p>原文转载自 <a href="https://segmentfault.com/a/1190000007736783">SegmentFault</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> exception </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化小结</title>
      <link href="/posts/59503/"/>
      <url>/posts/59503/</url>
      
        <content type="html"><![CDATA[<h2 id="1- 虚拟化的定义及分类"><a href="#1- 虚拟化的定义及分类" class="headerlink" title="1. 虚拟化的定义及分类"></a>1. 虚拟化的定义及分类 </h2><p> 这一部分是对当期存在的虚拟机技术进行简单的总结与讲解，很多是一句而过的。其实每一个技术都可以重新写出一篇内容丰富的博客，但是每个技术不是本篇文章的重点，所以不对每一个技术进行详细论述。欢迎对每个技术进行评论与纠错。</p><h3 id="1-1- 虚拟化定义："><a href="#1-1- 虚拟化定义：" class="headerlink" title="1.1 虚拟化定义："></a>1.1 虚拟化定义：</h3><p>虚拟化主要指的是特殊的技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境（称为虚拟机）(IBM 定义)。虚拟化为有效利用大型机的资源提供了技术支持。虚拟机技术也是多种多样，而可以虚拟的层次或者可虚拟的方面也是遍布从硬件到应用层整个计算机系统。如图片所示：</p><p><img src="https://images2017.cnblogs.com/blog/417876/201801/417876-20180127151547084-1841860602.png" alt="img"></p><h3 id="1-2- 虚拟机分类："><a href="#1-2- 虚拟机分类：" class="headerlink" title="1.2 虚拟机分类："></a>1.2 虚拟机分类：</h3><p>虚拟机的分类也是多种多样。可以通过是否在裸机上部署来分为面向主机的的虚拟机和面向裸机的虚拟机。面向主机的虚拟机是指的在一台已经安装操作系统的主机上安装虚拟机管理 (VMM) 程序，而面向裸机的是指在裸机上直接安装虚拟机管理程序，所有的虚拟机调用都是直接由虚拟机管理程序来负责，没有了操作系统这一步，所以这种方式在效率上要高于面向主机的。不过，比较流行的技术比如 vmware，Xen 都是面向主机的。</p><p>然后根据上面的图去分类的话，可以分为对 <strong> 硬件的虚拟 </strong> 和对 <strong> 操作系统或者对软件的虚拟</strong>。</p><p>在 <strong> 硬件虚拟化 </strong> 这个层面，又有三种不同的技术：</p><ol><li>Full Virtualization（全虚拟化），几乎是完整地模拟一套真实的硬件设备。大部分操作系统无须进行任何修改即可直接运行在全虚拟化环境中。像 KVM 等技术是全虚拟化。</li><li>Partial Virtualization（部分虚拟化），仅仅提供了对关键性计算组件或者指令集的模拟。操作系统可能需要做某些修改才能够运行在部分虚拟化环境中。</li><li>Paravirtualization（半虚拟化），不对硬件设备进行模拟，虚拟机拥有独立的运行环境，通过虚拟机管理程序共享底层的硬件资源。大部分操作系统需要进行修改才能够运行在半虚拟化环境中。它的性能要稍微高于全虚拟化。像 Xen。因为需要改动托管系统的内核，所以 Xen 是不支持 win 虚拟机的。</li></ol><p>另外还有像硬件辅助虚拟化，就是宿主机的硬件架构在一定程度上提供对虚拟化的支持。像 Intel-VT 与 AMD-V 都提供了这等架构支持，请参考给出的参考资料。</p><p><strong>软件层面的虚拟化</strong>，往往是指在同一个操作系统实例的基础上提供多个隔离的虚拟运行环境，也常常被称为容器技术。LXC（Linux Container）则是采用了这种技术，它主要是采用了 Linux 本身提供的技术，在一定程度上模拟虚拟化。软件虚拟化也可以理解成进程级虚拟机，其他虚拟化成为系统级虚拟机。在进程级虚拟机中负责虚拟化的软件成为运行时软件，而系统级虚拟机中负责虚拟化的软件成为 VMM(Virtual Machine Monitor)</p><p>对于硬件与软件虚拟化两种技术，都是存在优点和缺点。对于硬件虚拟化，我们讨论全虚拟化和部分虚拟化。因为现在大部分的虚拟化技术 Xen、KVM 都支持这两种。硬件虚拟化基本上就是在一台宿主机上虚拟了整个系统，各台虚拟机之间相互不可见。这会很明显导致很多重复的线程和重复的内存页出现，性能上肯定会有影响。所以采用这种技术，一台宿主机上虚拟机的个数肯定会有一定限制。</p><p>对于软件虚拟化，我们讨论 LXC，因为只有这一种我用过。LXC 是通过 cgroup 对线程进行隔离，对资源进行限制；通过 Namespace 对调用系统提供的系统调用来进行资源隔离。<a href="http://lxc.sourceforge.net/">LXC 介绍</a>。通过此也可以看出，它所有虚拟化出来的虚拟机都是运行在宿主机本身上的，它的线程和资源对宿主机都是可见的。这就不存在很多重复的线程和内存也的问题，所以一台宿主机上可以通过此技术虚拟出更多的虚拟机。</p><p>最近非常流行的 Docker 也是软件虚拟化的一种，它的原理也是使用了 Linux 提供的 namespace 对资源进行隔离，不过它提供了比 LXC 更强大的功能实现。</p><h2 id="2- 虚拟化技术"><a href="#2- 虚拟化技术" class="headerlink" title="2. 虚拟化技术"></a>2. 虚拟化技术 </h2><h3 id="2-1-kvm"><a href="#2-1-kvm" class="headerlink" title="2.1 kvm"></a>2.1 kvm</h3><p> 对于 KVM 来说，其是一款支持虚拟机技术，而且是 Linux 内核中的一个功能模块。它在 Linux2.6.20 之后的任何 Linux 分支中都被支持。它还有一个条件，对硬件要求的条件，必须达到一定标准的硬件架构。对于 Intel-VT 与 AMD-V 都是支持的。对于是否支持也可以通过命令行查看：egrep ‘(vmx|svm)’ –color&#x3D;always &#x2F;proc&#x2F;cpuinfo。如果有任何内容则说明当期硬件架构是支持 KVM 的，否则就不支持。另外，就算支持，但是在 bios 中是默认设置不打开该功能的，所以你还要去 bios 设置其为 enable。当设置成功之后，还需要关机一次，注意是关机而不是重启。否则该设置的更改就不起效。</p><p>KVM 是 linux 内核的模块，它需要 CPU 的支持，采用硬件辅助虚拟化技术 Intel-VT，AMD-V，内存的相关如 Intel 的 EPT 和 AMD 的 RVI 技术，Guest OS 的 CPU 指令不用再经过 Qemu 转译，直接运行，大大提高了速度，KVM 通过 &#x2F;dev&#x2F;kvm 暴露接口，用户态程序可以通过 ioctl 函数来访问这个接口。</p><p>KVM 内核模块本身只能提供 CPU 和内存的虚拟化，所以它必须结合 QEMU 才能构成一个完成的虚拟化技术，这就是下面要说的 qemu-kvm。</p><h3 id="2-2-qemu"><a href="#2-2-qemu" class="headerlink" title="2.2 qemu"></a>2.2 qemu</h3><p>QEMU 是什么。其实它也是一款虚拟化技术，就算不使用 KVM，单传的 QEMU 也可以完全实现一个虚拟机。那为何还会有 QEMU-KVM 这个名词那。是因为虽然 KVM 的技术已经相当成熟而且可以对很多东西进行隔离，但是在某些方面还是无法虚拟出真实的机器。比如对网卡的虚拟，那这个时候就需要另外的技术来做补充，而 QEMU-KVM 则是这样一种技术。它补充了 KVM 技术的不足，而且在性能上对 KVM 进行了优化。</p><p>QEMU 是一款开源的模拟器及虚拟机监管器(Virtual Machine Monitor, VMM)，它是构建基于 KVM 上面的，它提供了完整的网络和 I&#x2F;O 支持。</p><p>QEMU 主要提供两种功能给用户使用。 一是作为用户态模拟器，利用动态代码翻译机制来执行不同于主机架构的代码。 二是作为虚拟机监管器，模拟全系统，利用其他 VMM(Xen, KVM, etc)来使用硬件提供的虚拟化支持，创建接近于主机性能的虚拟机。 用户可以通过不同 Linux 发行版所带有的软件包管理器来安装 QEMU。</p><p>它向 Guest OS 模拟 CPU 和其他硬件，Guest OS 认为自己和硬件直接打交道，其实是同 Qemu 模拟出来的硬件打交道，Qemu 将这些指令转译给真正的硬件。</p><p>由于所有的指令都要从 Qemu 里面过一手，因而性能较差</p><p><img src="http://s3.51cto.com/wyfs02/M00/6F/77/wKiom1WdDYyjiVZiAAECBtAEQ5E590.jpg" alt="img"></p><h3 id="2-3-qemu-kvm"><a href="#2-3-qemu-kvm" class="headerlink" title="2.3 qemu-kvm"></a>2.3 qemu-kvm</h3><p>Qemu 将 KVM 整合进来，通过 ioctl 调用 &#x2F;dev&#x2F;kvm 接口，将有关 CPU 指令的部分交由内核模块来做。kvm 负责 cpu 虚拟化 + 内存虚拟化，实现了 cpu 和内存的虚拟化，但 kvm 不能模拟其他设备。qemu 模拟 IO 设备（网卡，磁盘等），kvm 加上 qemu 之后就能实现真正意义上服务器虚拟化。因为用到了上面两个东西，所以称之为 qemu-kvm。</p><p>Qemu 模拟其他的硬件，如 Network, Disk，同样会影响这些设备的性能，于是又产生了 pass through 半虚拟化设备 virtio_blk, virtio_net，提高设备性能。</p><p><img src="http://s3.51cto.com/wyfs02/M01/6F/77/wKiom1WdDc2CEwy6AAGPf4VzQao172.jpg" alt="img"></p><h3 id="2-4-libvirt"><a href="#2-4-libvirt" class="headerlink" title="2.4 libvirt"></a>2.4 libvirt</h3><p>libvirt 是一系列提供出来的库函数，用以其他技术调用，来管理机器上的虚拟机。包括各种虚拟机技术，KVM、Xen 与 lxc 等，都可以调用 libvirt 提供的 api 对虚拟机进行管理。有这么多的虚拟机技术，它为何能提供这么多的管理功能那。是因为它的设计理念，它是面向驱动的架构设计。对任何一种虚拟机技术都开发设计相对于该技术的驱动。这样不同虚拟机技术就可以使用不同驱动，而且相互直接不会影响，方便扩展。而且 libvirt 提供了多种语言的编程接口，可以直接通过编程，调用 libvirt 提供的对外接口实现对虚拟机的操作。如今流行的云计算中的 IaaS 是与该库联系相当密切的。</p><p>它是目前使用最为广泛的对 KVM 虚拟机进行管理的工具和 API。Libvirtd 是一个 daemon 进程，可以被本地的 virsh 调用，也可以被远程的 virsh 调用，Libvirtd 调用 qemu-kvm 操作虚拟机。</p><p><img src="http://s3.51cto.com/wyfs02/M02/6F/74/wKioL1WdD72RRy8mAAIuDm6sVAY591.jpg" alt="img"></p><p>通过下图可以看出它的架构设计思想。</p><p>从该图可以看出，在 libvirt api 之上会有很多个 driver，对于每一种虚拟机技术都会有一种 driver，用来充当该虚拟机技术与 libvirt 之间的包装接口。如此设计就可以避免 libvirt 需要设计各种针对不同虚拟机技术的接口，它主要关注底层的实现，提供对外接口调用，而不同的虚拟机技术通过调用 libvirt 提供的接口来完成自己所需要的功能。</p><p><img src="https://images2017.cnblogs.com/blog/417876/201801/417876-20180127151127147-2045532909.png" alt="img"></p><p>Openstack 通过 libvirt 去间接控制 qemu-kvm。libvirt 提供了跨 VM 平台的功能，它可以控制除了 QEMU 之外 的模拟器，包括 vmware, virtualbox， xen 等等。</p><p>所以为了 openstack 的跨 VM 性，所以 openstack 只会用 libvirt 而不直接用 qemu-kvm。libvirt 还提供了一些高级的功能，例如 pool&#x2F;vol 管理。</p><h2 id="3- 虚拟机网络"><a href="#3- 虚拟机网络" class="headerlink" title="3. 虚拟机网络"></a>3. 虚拟机网络 </h2><p> 一般虚拟机虚拟网络的设置主要包括三种方式。主要如下：</p><h3 id="3-1-NAT- 模式"><a href="#3-1-NAT- 模式" class="headerlink" title="3.1 NAT 模式"></a>3.1 NAT 模式 </h3><p> 也有人称此种模式为 HOST（宿主）模式。在这种模式下虚拟机可以理解成没有自己的独立网卡。所有访问虚拟机的请求其实是直接发送给宿主机，然后通过访问宿主机转发到虚拟机上的。相应的虚拟机访问其他网络，也是先转发到宿主机然后在转发出去。对于宿主机之外的网络，是不知道该虚拟机存在的。</p><h3 id="3-2-Bridge- 模式"><a href="#3-2-Bridge- 模式" class="headerlink" title="3.2 Bridge 模式"></a>3.2 Bridge 模式 </h3><p> 桥接模式是使用比较多的模式，它是虚拟机拥有自己的独立网卡和 IP，然后通过借用宿主机的网卡对外连接网络。它把宿主机的网卡当作了一种桥，通过这个桥连接外网的世界。在这种模式下，可以简单的理解成虚拟机和宿主机是两个不同的机器，有独立 IP 可以相互访问。对于虚拟机的 IP 获取，一般可以直接指定也可以通过 DHCP 获取得到。</p><h3 id="3-3-Internal- 模式"><a href="#3-3-Internal- 模式" class="headerlink" title="3.3 Internal 模式"></a>3.3 Internal 模式 </h3><p> 这个是把虚拟机之间的网络和主机的网络隔离开来。虚拟机是一片网络，主机也是一片网络，彼此之间不能相互访问。</p><h2 id="4- 关系"><a href="#4- 关系" class="headerlink" title="4. 关系"></a>4. 关系</h2><p>KVM 虚拟机是基于 Linux 内核虚拟化，自 Linux2.6.20 之后就集成在 Linux 的各个主要发行版本中。它使用 Linux 自身的调度器进行管理，所以相对于 Xen，其核心源码很少。KVM 的虚拟化需要硬件的支持（如 intel VT 技术或者 AMD V 技术），是基于硬件的完全虚拟化。而 Xen 早期则是基于软件模拟的 para-virtualization，新版本是基于硬件支持的完全虚拟化。</p><p>QEMU 是一种模拟处理器，现在运用最多的就是将 KVM 和 QEMU 结合起来。</p><p>准确来说，KVM 是 Linux Kernel 的一个模块，可以用命令 modprobe 去加载 KVM 模块。加载了该模块后，才能进一步通过工具创建虚拟机。但是仅有 KVM 模块是不够的。因为用户无法直接控制内核去做事情，还必须有一个运行在用户空间的工具才行。这个用户空间的工具，KVM 开发者选择了已经成型的开源虚拟化软件 QEMU。说起来 QEMU 也是一个虚拟化软件。它的特点是可虚拟不同的 CPU。比如说在 x86 的 CPU 上可虚拟一个 power 的 CPU，并可利用它编译出可运行在 power 上的 CPU，并可利用它编译出可运行在 power 上的程序。KVM 使用了 QEMU 的一部分，并稍加改造，就成了可控制 KVM 的用户空间工具了。所以你会看到，官方提供的 KVM 下载有两大部分 (QEMU 和 KVM) 三个文件(KVM 模块、QEMU 工具以及二者的合集)。也就是说，你可以只升级 KVM 模块，也可以只升级 QEMU 工具。这就是 KVM 和 QEMU 的关系。</p><p>如下图：</p><p><img src="https://images2017.cnblogs.com/blog/417876/201801/417876-20180127152001022-514486494.png" alt="img"></p><p>Linux Kernel-based Virtual Machine (KVM) 是一款 Linux 开放源码虚拟化软件，基于硬件虚拟化扩展（Intel VT- X 和 AMD-V）和 QEMU 的修改版。KVM 的实现模块又两个，分别是： kvm.ko 是提供核心虚拟化的基础架构；特定于处理器的模块 kvm-intel.ko 和 kvm-amd.ko 。其设计目标是在需要引导多个未改动的 P 操作系统时支持完整的硬件模拟。</p><p>一个普通的 Linux 进程有两种运行模式：内核和用户。而 KVM 增加了第三种模式：客户模式（有自己的内核和用户模式）。在 KVM 模型中，每一个虚拟机都是由 Linux 调度程序管理的标准进程。</p><p>KVM 由两个部分组成：一个是管理虚拟硬件的设备驱动，该驱动使用字符设备 &#x2F;dev&#x2F;kvm 作为管理接口；另一个是模拟 PC 硬件的用户空间组件，这是一个稍作修改的 QEMU 进程。</p><h2 id="5- 参考："><a href="#5- 参考：" class="headerlink" title="5. 参考："></a>5. 参考：</h2><ul><li><p><a href="http://virt-manager.org/">VirtManager 介绍</a></p></li><li><p><a href="https://zh.wikipedia.org/wiki/%E6%B3%A2%E4%BD%A9%E5%85%8B%E4%B8%8E%E6%88%88%E5%BE%B7%E5%A0%A1%E8%99%9A%E6%8B%9F%E5%8C%96%E9%9C%80%E6%B1%82">wiki 波佩克与戈德堡虚拟化需求</a></p></li><li><p><a href="https://lwn.net/Articles/531114/">Linux namespace 介绍</a></p></li><li><p><a href="http://zh.wikipedia.org/wiki/X86%E8%99%9A%E6%8B%9F%E5%8C%96">Intel-VT 介绍</a></p></li><li><p><a href="http://blog.csdn.net/zwan0518/article/details/10613481">虚拟化技术以及 KVM、QEMU 与 libvirt 介绍</a>（以上内容部分转自此篇文章）</p></li><li><p><a href="http://blog.chinaunix.net/uid-16361381-id-211999.html">kvm 和 qemu 的关系</a></p></li><li><p><a href="http://blog.csdn.net/chdhust/article/details/7557791">KVM&#x2F;QEMU 简介</a></p></li><li><p><a href="https://www.cnblogs.com/bakari/p/7858029.html">https://www.cnblogs.com/bakari/p/7858029.html</a></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker volume 的 rw 和 ro 区别</title>
      <link href="/posts/45989/"/>
      <url>/posts/45989/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h2><p>docker run 或者 docker-compose 可以挂载卷，并且可对 volume 设定读写权限</p><h2 id="区别"><a href="# 区别" class="headerlink" title="区别"></a>区别 </h2><h3 id="不指定（默认）"><a href="# 不指定（默认）" class="headerlink" title="不指定（默认）"></a> 不指定（默认）</h3><ul><li>文件：<ul><li>宿主机 修改该文件后容器里面看不到变化</li><li>容器 里面修改该文件，宿主机也看不到变化</li></ul></li><li>文件夹：不管是宿主机还是容器内 修改、新增、删除文件 都会相互同步</li><li></li></ul><h3 id="ro"><a href="#ro" class="headerlink" title="ro"></a>ro</h3><ul><li>文件：容器内不能修改，会提示 read-only</li><li>文件夹：容器内不能修改、新增、删除文件夹中的文件，会提示 read-only</li></ul><h3 id="rw"><a href="#rw" class="headerlink" title="rw"></a>rw</h3><ul><li>文件：不管是宿主机还是容器内修改，都会相互同步；但容器内不允许删除，会提示 Device or resource busy；宿主机删除文件，容器内的不会被同步</li><li>文件夹：不管是宿主机还是容器内修改、新增、删除文件，都会相互同步</li></ul><h2 id="注意"><a href="# 注意" class="headerlink" title="注意"></a>注意 </h2><p> 当容器内 uid 与宿主机 uid 不同时，可能存在挂载的容器内的文件读写权限问题</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 部署 webmail Rainloop</title>
      <link href="/posts/3015/"/>
      <url>/posts/3015/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="# 简介" class="headerlink" title="简介"></a>简介</h2><p>RainLoop 是基于 WEB 的邮件服务器系统是一个免费开源的 PHP Web Mail 客户端系统应用工具，可以用一个界面管理多个帐号，该程序拥有简洁的界面和全面的功能，支持 SMTP+IMAP。</p><p>用来配合 maddy 可以非常方便的搭建一套完整的带 webmail 的电子邮件服务。</p><h2 id="步骤"><a href="# 步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1- 下载 -rainloop- 安装包"><a href="#1- 下载 -rainloop- 安装包" class="headerlink" title="1. 下载 rainloop 安装包"></a>1. 下载 rainloop 安装包</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir rainloop &amp;&amp; cd rainloop</span><br><span class="line">wget -q https://www.rainloop.net/repository/webmail/rainloop-community-latest.zip</span><br><span class="line">unzip rainloop-community-latest.zip -d rainloop</span><br><span class="line">chmod -R 777 rainloop</span><br></pre></td></tr></table></figure><h3 id="2- 下载 -docker-compose- 文件"><a href="#2- 下载 -docker-compose- 文件" class="headerlink" title="2. 下载 docker-compose 文件"></a>2. 下载 docker-compose 文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q https://raw.githubusercontent.com/Chasing66/beautiful_docker/main/maddy/rainloop/docker-compose.yml</span><br></pre></td></tr></table></figure><h3 id="3- 下载 -nginx- 配置文件"><a href="#3- 下载 -nginx- 配置文件" class="headerlink" title="3. 下载 nginx 配置文件"></a>3. 下载 nginx 配置文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -q https://raw.githubusercontent.com/Chasing66/beautiful_docker/main/maddy/rainloop/rainloop.conf</span><br></pre></td></tr></table></figure><h3 id="4- 拉起 -docker"><a href="#4- 拉起 -docker" class="headerlink" title="4. 拉起 docker"></a>4. 拉起 docker</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="5- 登录后台初始配置"><a href="#5- 登录后台初始配置" class="headerlink" title="5. 登录后台初始配置"></a>5. 登录后台初始配置 </h3><p> 地址为：<a href="http://ip/?admin">http://ip/?admin</a><br>初始用户名密码为： admin&#x2F;12345，请及时修改 <br> 配置好搭建的 maddy 地址，访问 <a href="http://ip, 使用 /">http://ip，使用</a> maddy 里创建的用户登录即可从网页端发送邮件</p><h3 id="6- 其他"><a href="#6- 其他" class="headerlink" title="6. 其他"></a>6. 其他 </h3><p> 也可使用 windows 客户端<a href="https://www.thunderbird.net/">thunderbird</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> maddy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lsof 常用技巧</title>
      <link href="/posts/43458/"/>
      <url>/posts/43458/</url>
      
        <content type="html"><![CDATA[<h3 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言</h3><p>lsof: lists openfiles. 在 Unix 中一切（包括网络套接口）都是文件。</p><p>例如：</p><ul><li>普通文件</li><li>目录</li><li>符号链接</li><li>面向块的设备文件</li><li>面向字符的设备文件</li><li>管道和命名管道</li><li>套接字</li><li>…</li></ul><h3 id="关键选项"><a href="# 关键选项" class="headerlink" title="关键选项"></a>关键选项 </h3><p> 理解一些关于 lsof 如何工作的关键性东西是很重要的。最重要的是，当你给它传递选项时，默认行为是对结果进行“或”运算。因此，如果你正是用 -i 来拉出一个端口列表，同时又用 -p 来拉出一个进程列表，那么默认情况下你会获得两者的结果。</p><p>下面的一些其它东西需要牢记：</p><ul><li>默认 : 没有选项，lsof 列出活跃进程的所有打开文件</li><li>组合 : 可以将选项组合到一起，如 -abc，但要当心哪些选项需要参数</li><li>-a : 结果进行“与”运算（而不是“或”）</li><li>-l : 在输出显示用户 ID 而不是用户名</li><li>-h : 获得帮助</li><li>-t : 仅获取进程 ID</li><li>-U : 获取 UNIX 套接口地址</li><li>-F : 格式化输出结果，用于其它命令。可以通过多种方式格式化，如 -F pcfn（用于进程 id、命令名、文件描述符、文件名，并以空终止）</li></ul><h3 id="1- 获取网络信息"><a href="#1- 获取网络信息" class="headerlink" title="1. 获取网络信息"></a>1. 获取网络信息 </h3><p> 正如我所说的，我主要将 lsof 用于获取关于系统怎么和网络交互的信息。这里提供了关于此信息的一些主题：</p><h4 id="1-1- 使用 -i 显示所有连接"><a href="#1-1- 使用 -i 显示所有连接" class="headerlink" title="1.1 使用 -i 显示所有连接"></a>1.1 使用 <code>-i</code> 显示所有连接 </h4><p> 语法: lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#  lsof  -<span class="selector-tag">i</span></span><br><span class="line"></span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME</span><br><span class="line">dhcpcd <span class="number">6061</span> root <span class="number">4</span>u  IPv4  <span class="number">4510</span> UDP *:bootpc</span><br><span class="line">sshd  <span class="number">7703</span> root <span class="number">3</span>u  IPv6  <span class="number">6499</span> TCP *:ssh  (LISTEN)</span><br><span class="line">sshd  <span class="number">7892</span> root <span class="number">3</span>u  IPv6  <span class="number">6757</span> TCP <span class="number">10.10</span>.<span class="number">1.5</span>:ssh-&gt;<span class="number">192.168</span>.<span class="number">1.5</span>:<span class="number">49901</span>  (ESTABLISHED)</span><br></pre></td></tr></table></figure><h4 id="使用 -i-6- 仅获取 -IPv6- 流量"><a href="# 使用 -i-6- 仅获取 -IPv6- 流量" class="headerlink" title="使用 -i 6 仅获取 IPv6 流量"></a>使用<code>-i 6</code> 仅获取 IPv6 流量</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i 6</span></span><br></pre></td></tr></table></figure><h4 id="仅显示 -TCP- 连接（同理可获得 -UDP- 连接）"><a href="# 仅显示 -TCP- 连接（同理可获得 -UDP- 连接）" class="headerlink" title="仅显示 TCP 连接（同理可获得 UDP 连接）"></a>仅显示 TCP 连接（同理可获得 UDP 连接）</h4><p>你也可以通过在 -i 后提供对应的协议来仅仅显示 TCP 或者 UDP 连接信息。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lsof  -iTCP</span><br><span class="line"></span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME</span><br><span class="line">sshd  <span class="number">7703</span> root <span class="number">3</span>u  IPv6  <span class="number">6499</span> TCP *:ssh  (LISTEN)</span><br><span class="line">sshd  <span class="number">7892</span> root <span class="number">3</span>u  IPv6  <span class="number">6757</span> TCP <span class="number">10.10</span>.<span class="number">1.5</span>:ssh-&gt;<span class="number">192.168</span>.<span class="number">1.5</span>:<span class="number">49901</span>  (ESTABLISHED)</span><br></pre></td></tr></table></figure><h4 id="使用 -i-port 来显示与指定端口相关的网络信息"><a href="# 使用 -i-port 来显示与指定端口相关的网络信息" class="headerlink" title="使用 -i :port 来显示与指定端口相关的网络信息"></a>使用 <code>-i :port</code> 来显示与指定端口相关的网络信息 </h4><p> 或者，你也可以通过端口搜索，这对于要找出什么阻止了另外一个应用绑定到指定端口实在是太棒了。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#  lsof  -<span class="selector-tag">i</span> :<span class="number">22</span></span><br><span class="line"></span><br><span class="line">COMMAND  PID USER   FD   TYPE DEVICE SIZE NODE NAME</span><br><span class="line">sshd  <span class="number">7703</span> root <span class="number">3</span>u  IPv6  <span class="number">6499</span> TCP *:ssh  (LISTEN)</span><br><span class="line">sshd  <span class="number">7892</span> root <span class="number">3</span>u  IPv6  <span class="number">6757</span> TCP <span class="number">10.10</span>.<span class="number">1.5</span>:ssh-&gt;<span class="number">192.168</span>.<span class="number">1.5</span>:<span class="number">49901</span>  (ESTABLISHED)</span><br></pre></td></tr></table></figure><h4 id="使用 -host 来显示指定到指定主机的连接"><a href="# 使用 -host 来显示指定到指定主机的连接" class="headerlink" title="使用 @host 来显示指定到指定主机的连接"></a>使用 <code>@host</code> 来显示指定到指定主机的连接 </h4><p> 这对于你在检查是否开放连接到网络中或互联网上某个指定主机的连接时十分有用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#  lsof  -<span class="selector-tag">i</span><span class="keyword">@172</span>.16.12.5</span><br><span class="line"></span><br><span class="line">sshd  <span class="number">7892</span> root <span class="number">3</span>u  IPv6  <span class="number">6757</span> TCP <span class="number">10.10</span>.<span class="number">1.5</span>:ssh-&gt;<span class="number">172.16</span>.<span class="number">12.5</span>:<span class="number">49901</span>  (ESTABLISHED)</span><br></pre></td></tr></table></figure><h4 id="使用 -host-port- 显示基于主机与端口的连接"><a href="# 使用 -host-port- 显示基于主机与端口的连接" class="headerlink" title="使用 @host:port 显示基于主机与端口的连接"></a>使用 @host:port 显示基于主机与端口的连接 </h4><p> 你也可以组合主机与端口的显示信息。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i@172.16.12.5:22</span></span><br><span class="line"></span><br><span class="line">sshd  <span class="number">7892</span> root 3u  <span class="title class_">IPv6</span>  <span class="number">6757</span> <span class="variable constant_">TCP</span> <span class="number">10.10</span>.<span class="number">1.5</span><span class="symbol">:ssh-&gt;</span><span class="number">172.16</span>.<span class="number">12.5</span><span class="symbol">:</span><span class="number">49901</span>  (<span class="variable constant_">ESTABLISHED</span>)</span><br></pre></td></tr></table></figure><h4 id="找出监听端口"><a href="# 找出监听端口" class="headerlink" title="找出监听端口"></a>找出监听端口 </h4><p> 找出正等候连接的端口。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i -sTCP:LISTEN</span></span><br></pre></td></tr></table></figure><p>也可以 grep “LISTEN”来完成该任务。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i |  grep  -i LISTEN</span></span><br><span class="line"></span><br><span class="line">iTunes <span class="number">400</span> daniel 16u  <span class="title class_">IPv4</span>  <span class="number">0x4575228</span>  0t0 <span class="variable constant_">TCP</span> *<span class="symbol">:daap</span> (<span class="variable constant_">LISTEN</span>)</span><br></pre></td></tr></table></figure><h4 id="找出已建立的连接"><a href="# 找出已建立的连接" class="headerlink" title="找出已建立的连接"></a>找出已建立的连接 </h4><p> 你也可以显示任何已经连接的连接。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i -sTCP:ESTABLISHED</span></span><br></pre></td></tr></table></figure><p>也可以通过 grep 搜索“ESTABLISHED”来完成该任务。</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i |  grep  -i ESTABLISHED</span></span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.  firefox-b <span class="number">169</span> daniel 49u  <span class="title class_">IPv4</span>  0t0 <span class="variable constant_">TCP</span> <span class="number">1.2</span>.<span class="number">3.3</span><span class="symbol">:</span><span class="number">1863</span>-&gt;<span class="number">1.2</span>.<span class="number">3.4</span><span class="symbol">:http</span> (<span class="variable constant_">ESTABLISHED</span>)</span><br></pre></td></tr></table></figure><h3 id="2- 获取用户信息"><a href="#2- 获取用户信息" class="headerlink" title="2. 获取用户信息"></a>2. 获取用户信息 </h3><p> 你也可以获取各种用户的信息，以及它们在系统上正干着的事情，包括它们的网络活动、对文件的操作等。</p><h4 id="使用 -u- 显示指定用户打开了什么"><a href="# 使用 -u- 显示指定用户打开了什么" class="headerlink" title="使用 -u 显示指定用户打开了什么"></a>使用 -u 显示指定用户打开了什么</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lsof  -u daniel</span><br><span class="line"></span><br><span class="line">-- snipped --</span><br><span class="line">Dock  155 daniel  txt REG 14,2  2798436  823208  /usr/lib/libicucore.A.dylib</span><br><span class="line">Dock  155 daniel  txt REG 14,2  1580212  823126  /usr/lib/libobjc.A.dylib</span><br><span class="line">Dock  155 daniel  txt REG 14,2  2934184  823498  /usr/lib/libstdc++.6.0.4.dylib</span><br><span class="line">Dock  155 daniel  txt REG 14,2  132008  823505  /usr/lib/libgcc_s.1.dylib</span><br><span class="line">Dock  155 daniel  txt REG 14,2  212160  823214  /usr/lib/libauto.dylib</span><br><span class="line">  -- snipped --</span><br></pre></td></tr></table></figure><h4 id="使用 -u-user 来显示除指定用户以外的其它所有用户所做的事情"><a href="# 使用 -u-user 来显示除指定用户以外的其它所有用户所做的事情" class="headerlink" title="使用 -u user 来显示除指定用户以外的其它所有用户所做的事情"></a>使用 <code>-u user</code> 来显示除指定用户以外的其它所有用户所做的事情</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -u ^daniel</span></span><br><span class="line"></span><br><span class="line">-- snipped --</span><br><span class="line">Dock  155 jim  txt REG 14,2  2798436  823208  /usr/lib/libicucore.A.dylib</span><br><span class="line">Dock  155 jim  txt REG 14,2  1580212  823126  /usr/lib/libobjc.A.dylib</span><br><span class="line">Dock  155 jim  txt REG 14,2  2934184  823498  /usr/lib/libstdc++.6.0.4.dylib</span><br><span class="line">Dock  155 jim  txt REG 14,2  132008  823505  /usr/lib/libgcc_s.1.dylib</span><br><span class="line"> Dock  155 jim  txt REG 14,2  212160  823214  /usr/lib/libauto.dylib</span><br><span class="line">-- snipped --</span><br></pre></td></tr></table></figure><h4 id="杀死指定用户所做的一切事情"><a href="# 杀死指定用户所做的一切事情" class="headerlink" title="杀死指定用户所做的一切事情"></a>杀死指定用户所做的一切事情 </h4><p> 可以消灭指定用户运行的所有东西，这真不错。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  kill  -9  `lsof -t -u daniel`</span></span><br></pre></td></tr></table></figure><h3 id="3- 命令和进程"><a href="#3- 命令和进程" class="headerlink" title="3. 命令和进程"></a>3. 命令和进程 </h3><p> 可以查看指定程序或进程由什么启动，这通常会很有用，而你可以使用 lsof 通过名称或进程 ID 过滤来完成这个任务。下面列出了一些选项：</p><h4 id="使用 -c 查看指定的命令正在使用的文件和网络连接"><a href="# 使用 -c 查看指定的命令正在使用的文件和网络连接" class="headerlink" title="使用 -c 查看指定的命令正在使用的文件和网络连接"></a>使用 <code>-c</code> 查看指定的命令正在使用的文件和网络连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.  <span class="comment">#  lsof  -c syslog-ng</span></span><br><span class="line"></span><br><span class="line">3.  COMMAND    PID USER   FD   TYPE     DEVICE    SIZE       NODE NAME</span><br><span class="line">4.  syslog-ng 7547 root  cwd    DIR 3,3  4096  2  /</span><br><span class="line">5.  syslog-ng 7547 root  rtd    DIR 3,3  4096  2  /</span><br><span class="line">6.  syslog-ng 7547 root  txt    REG 3,3  113524  1064970  /usr/sbin/syslog-ng</span><br><span class="line">7.  -- snipped --</span><br></pre></td></tr></table></figure><h4 id="使用 -p 查看指定进程 -ID- 已打开的内容"><a href="# 使用 -p 查看指定进程 -ID- 已打开的内容" class="headerlink" title="使用 -p 查看指定进程 ID 已打开的内容"></a>使用 <code>-p</code> 查看指定进程 ID 已打开的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1.  <span class="comment">#  lsof  -p 10075</span></span><br><span class="line"></span><br><span class="line">3.  -- snipped --</span><br><span class="line">4.  sshd  10068 root  mem    REG 3,3  34808  850407  /lib/libnss_files-2.4.so</span><br><span class="line">5.  sshd  10068 root  mem    REG 3,3  34924  850409  /lib/libnss_nis-2.4.so</span><br><span class="line">6.  sshd  10068 root  mem    REG 3,3  26596  850405  /lib/libnss_compat-2.4.so</span><br><span class="line">7.  sshd  10068 root  mem    REG 3,3  200152  509940  /usr/lib/libssl.so.0.9.7</span><br><span class="line">8.  sshd  10068 root  mem    REG 3,3  46216  510014  /usr/lib/liblber-2.3</span><br><span class="line">9.  sshd  10068 root  mem    REG 3,3  59868  850413  /lib/libresolv-2.4.so</span><br><span class="line">10.  sshd  10068 root  mem    REG 3,3  1197180  850396  /lib/libc-2.4.so</span><br><span class="line">11.  sshd  10068 root  mem    REG 3,3  22168  850398  /lib/libcrypt-2.4.so</span><br><span class="line">12.  sshd  10068 root  mem    REG 3,3  72784  850404  /lib/libnsl-2.4.so</span><br><span class="line">13.  sshd  10068 root  mem    REG 3,3  70632  850417  /lib/libz.so.1.2.3</span><br><span class="line">14.  sshd  10068 root  mem    REG 3,3  9992  850416  /lib/libutil-2.4.so</span><br><span class="line">15.  -- snipped --</span><br></pre></td></tr></table></figure><h4 id="t 选项只返回 -PID"><a href="#t 选项只返回 -PID" class="headerlink" title="-t 选项只返回 PID"></a><code>-t</code>选项只返回 PID</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -t -c Mail</span></span><br><span class="line"></span><br><span class="line">350</span><br></pre></td></tr></table></figure><h3 id="4- 文件和目录"><a href="#4- 文件和目录" class="headerlink" title="4. 文件和目录"></a>4. 文件和目录 </h3><p> 通过查看指定文件或目录，你可以看到系统上所有正与其交互的资源——包括用户、进程等。</p><h4 id="显示与指定目录交互的所有一切"><a href="# 显示与指定目录交互的所有一切" class="headerlink" title="显示与指定目录交互的所有一切"></a>显示与指定目录交互的所有一切</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.  <span class="comment">#  lsof  /var/log/messages/</span></span><br><span class="line"></span><br><span class="line">3.  COMMAND    PID USER   FD   TYPE DEVICE   SIZE   NODE NAME</span><br><span class="line">4.  syslog-ng 7547 root 4w REG 3,3  217309  834024  /var/log/messages</span><br></pre></td></tr></table></figure><h3 id="显示与指定文件交互的所有一切"><a href="# 显示与指定文件交互的所有一切" class="headerlink" title="显示与指定文件交互的所有一切"></a>显示与指定文件交互的所有一切</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  /home/daniel/firewall_whitelist.txt</span></span><br></pre></td></tr></table></figure><h3 id="5- 高级用法"><a href="#5- 高级用法" class="headerlink" title="5. 高级用法"></a>5. 高级用法 </h3><p> 与<a href="http://danielmiessler.com/study/tcpdump/">tcpdump</a>类似，当你开始组合查询时，它就显示了它强大的功能。</p><h4 id="显示 -daniel- 连接到 -1-1-1-1- 所做的一切"><a href="# 显示 -daniel- 连接到 -1-1-1-1- 所做的一切" class="headerlink" title="显示 daniel 连接到 1.1.1.1 所做的一切"></a>显示 daniel 连接到 1.1.1.1 所做的一切</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>.  #  lsof  -u daniel -<span class="selector-tag">i</span> <span class="keyword">@1</span>.1.1.1</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>.  bkdr <span class="number">1893</span> daniel <span class="number">3</span>u  IPv6  <span class="number">3456</span> TCP <span class="number">10.10</span>.<span class="number">1.10</span>:<span class="number">1234</span>-&gt;<span class="number">1.1</span>.<span class="number">1.1</span>:<span class="number">31337</span>  (ESTABLISHED)</span><br></pre></td></tr></table></figure><h4 id="同时使用 -t- 和 -c- 选项以给进程发送 -HUP- 信号"><a href="# 同时使用 -t- 和 -c- 选项以给进程发送 -HUP- 信号" class="headerlink" title="同时使用 -t 和 -c 选项以给进程发送 HUP 信号"></a>同时使用 -t 和 -c 选项以给进程发送 HUP 信号</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  kill  -HUP `lsof -t -c sshd`</span></span><br></pre></td></tr></table></figure><h4 id="lsof-L1- 显示所有打开的链接数小于 -1- 的文件"><a href="#lsof-L1- 显示所有打开的链接数小于 -1- 的文件" class="headerlink" title="lsof +L1 显示所有打开的链接数小于 1 的文件"></a>lsof +L1 显示所有打开的链接数小于 1 的文件 </h4><p> 这通常（当不总是）表示某个攻击者正尝试通过删除文件入口来隐藏文件内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  +L1</span></span><br><span class="line"></span><br><span class="line">(hopefully nothing)</span><br></pre></td></tr></table></figure><h4 id="显示某个端口范围的打开的连接"><a href="# 显示某个端口范围的打开的连接" class="headerlink" title="显示某个端口范围的打开的连接"></a>显示某个端口范围的打开的连接</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#  lsof  -i <span class="doctag">@fw</span>.google.com:2150=2180</span></span><br></pre></td></tr></table></figure><h3 id="结尾"><a href="# 结尾" class="headerlink" title="结尾"></a>结尾 </h3><p> 本入门教程只是管窥了 lsof 功能的一斑，要查看完整参考，运行 man lsof 命令或查看 <a href="http://www.netadmintools.com/html/lsof.man.html"> 在线版本 </a>。希望本文对你有所助益，也随时<a href="http://danielmiessler.com/connect/"> 欢迎你的评论和指正</a>。</p><h3 id="资源"><a href="# 资源" class="headerlink" title="资源"></a>资源</h3><ul><li>lsof 手册页：<a href="http://www.netadmintools.com/html/lsof.man.html">http://www.netadmintools.com/html/lsof.man.html</a></li></ul><p>本文由 Daniel Miessler 撰写，首次在他 <a href="http://danielmiessler.com/study/lsof/"> 博客 </a> 上贴出</p><p>一般 root 用户才能执行 lsof 命令，普通用户可以看见 &#x2F;usr&#x2F;sbin&#x2F;lsof 命令，<br>但是普通用户执行会显示“permission denied”</p><p>我总结一下 lsof 指令的用法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">lsof abc.txt 显示开启文件 abc.txt 的进程 </span><br><span class="line"></span><br><span class="line">lsof -i :22 知道 22 端口现在运行什么程序</span><br><span class="line"></span><br><span class="line">lsof -c abc 显示 abc 进程现在打开的文件</span><br><span class="line"></span><br><span class="line">lsof -g gid 显示归属 gid 的进程情况</span><br><span class="line"></span><br><span class="line">lsof +d /usr/local/ 显示目录下被进程开启的文件</span><br><span class="line"></span><br><span class="line">lsof +D /usr/local/ 同上，但是会搜索目录下的目录，时间较长</span><br><span class="line"></span><br><span class="line">lsof -d 4 显示使用 fd 为 4 的进程  [www.2cto.com](http://www.2cto.com)</span><br><span class="line"></span><br><span class="line">lsof -i 用以显示符合条件的进程情况</span><br><span class="line"></span><br><span class="line"> 语法: lsof -i[46] [protocol][@hostname|hostaddr][:service|port]</span><br><span class="line"></span><br><span class="line">46 --&gt; IPv4 or IPv6</span><br><span class="line"></span><br><span class="line">protocol --&gt; TCP or UDP</span><br><span class="line"></span><br><span class="line">hostname --&gt; Internet host name</span><br><span class="line"></span><br><span class="line">hostaddr --&gt; IPv4 位置 </span><br><span class="line"></span><br><span class="line">service --&gt; /etc/service 中的 service name (可以不只一个)</span><br><span class="line"></span><br><span class="line">port --&gt; 端口号 (可以不只一个)</span><br><span class="line"></span><br><span class="line"> 例子: TCP:25 - TCP and port 25</span><br><span class="line"></span><br><span class="line">@1.2.3.4 - Internet IPv4 host address 1.2.3.4</span><br><span class="line"></span><br><span class="line">[tcp@ohaha.ks.edu.tw](mailto:tcp@ohaha.ks.edu.tw):ftp - TCP protocol [hosthaha.ks.edu.tw](http://hosthaha.ks.edu.tw) service name:ftp</span><br><span class="line"></span><br><span class="line">lsof -n 不将 IP 转换为 hostname，缺省是不加上 -n 参数 </span><br><span class="line"></span><br><span class="line"> 例子: lsof -i [tcp@ohaha.ks.edu.tw](mailto:tcp@ohaha.ks.edu.tw):ftp -n</span><br><span class="line"></span><br><span class="line">lsof -p 12 看进程号为 12 的进程打开了哪些文件 </span><br><span class="line"></span><br><span class="line">lsof +|-r [t] 控制 lsof 不断重复执行，缺省是 15s 刷新</span><br><span class="line"></span><br><span class="line">-r，lsof 会永远不断的执行，直到收到中断信号</span><br><span class="line"></span><br><span class="line">+r，lsof 会一直执行，直到没有档案被显示</span><br><span class="line"></span><br><span class="line"> 例子：不断查看目前 ftp 连接的情况：lsof -i [tcp@ohaha.ks.edu.tw](mailto:tcp@ohaha.ks.edu.tw):ftp -r</span><br><span class="line"></span><br><span class="line">lsof -s 列出打开文件的大小，如果没有大小，则留下空白</span><br><span class="line"></span><br><span class="line">lsof -u username 以 UID，列出打开的文件  [www.2cto.com](http://www.2cto.com)</span><br></pre></td></tr></table></figure><blockquote><p>原文转载自 <a href="https://www.jianshu.com/p/a3aa6b01b2e1">https://www.jianshu.com/p/a3aa6b01b2e1</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> lsof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 搭建 Maddy 多合一邮件服务器</title>
      <link href="/posts/36902/"/>
      <url>/posts/36902/</url>
      
        <content type="html"><![CDATA[<p>GitHub <a href="https://github.com/Chasing66/beautiful_docker/tree/main/maddy">Chasing66&#x2F;beautiful_docker</a><br>Docker <a href="https://hub.docker.com/r/enwaiax/maddy">enwaiax&#x2F;maddy</a></p><blockquote><p>*docker image support for AMD64 and ARM64</p></blockquote><h2 id="简介"><a href="# 简介" class="headerlink" title="简介"></a>简介 </h2><p> 基于 <a href="https://github.com/foxcpp/maddy">foxcpp&#x2F;maddy</a> 项目的 docker 镜像.</p><p>Maddy 是一款用 Go 语言开发的邮件服务器，它实现了运行电子邮件服务器所需的所有功能。</p><p>Maddy 用一个具有统一配置和最低维护成本的守护进程取代了 Postfix、Dovecot、OpenDKIM、OpenSPF、OpenDMARC 等程序。</p><p>通俗点讲就是部署特别方便, 资源占用少，非常适合个人使用的电子邮件服务器。</p><h2 id="预置条件"><a href="# 预置条件" class="headerlink" title="预置条件"></a>预置条件 </h2><p> 检查 25 端口是否开放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet smtp.aol.com 25</span><br></pre></td></tr></table></figure><h2 id="部署步骤"><a href="# 部署步骤" class="headerlink" title="部署步骤"></a>部署步骤 </h2><h3 id="创建 -docker-volume"><a href="# 创建 -docker-volume" class="headerlink" title="创建 docker volume"></a> 创建 docker volume</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker volume create maddydata</span><br></pre></td></tr></table></figure><h3 id="创建 -tls- 证书"><a href="# 创建 -tls- 证书" class="headerlink" title="创建 tls 证书"></a>创建 tls 证书 </h3><p> 申请证书步骤略过，将证书 copy 并重命为 <code>tls_key.pem</code> 和<code>tls_cert.pem</code>到 volume 目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker volume 目录 </span></span><br><span class="line">cd $(docker volume inspect maddydata --format &#x27;&#123;&#123;.Mountpoint&#125;&#125;&#x27;)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 拷贝并重命名证书到当前目录</span></span><br><span class="line">cp /etc/letsencrypt/live/mx1.example.org/cert.pem tls_cert.pem</span><br><span class="line">cp /etc/letsencrypt/live/mx1.example.org/privkey.pem tls_key.pem</span><br></pre></td></tr></table></figure><h3 id="设置 -hostname- 和 -domainname"><a href="# 设置 -hostname- 和 -domainname" class="headerlink" title="设置 hostname 和 domainname"></a>设置 hostname 和 domainname</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MADDY_HOSTNAME=mx1.example.org</span><br><span class="line">export MADDY_DOMAIN=example.org</span><br></pre></td></tr></table></figure><h3 id="创建 -maddy- 实例"><a href="# 创建 -maddy- 实例" class="headerlink" title="创建 maddy 实例"></a>创建 maddy 实例 </h3><h4 id="使用 -docker- 创建"><a href="# 使用 -docker- 创建" class="headerlink" title="使用 docker 创建"></a> 使用 docker 创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name maddy \</span><br><span class="line">  -e MADDY_HOSTNAME=$MADDY_HOSTNAME -e MADDY_DOMAIN=$MADDY_DOMAIN \</span><br><span class="line">  -v maddydata:/data \</span><br><span class="line">  -p 25:25 -p 143:143 -p 465:465 -p 587:587 -p 993:993 \</span><br><span class="line">  enwaiax/maddy:latest</span><br></pre></td></tr></table></figure><h4 id="使用 -docker-compose- 创建"><a href="# 使用 -docker-compose- 创建" class="headerlink" title="使用 docker-compose 创建"></a>使用 docker-compose 创建</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir maddy &amp;&amp; cd maddy</span><br><span class="line">wget https://raw.githubusercontent.com/Chasing66/beautiful_docker/main/maddy/docker-compose.yml</span><br><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure><h3 id="配置 -DNS- 记录解析"><a href="# 配置 -DNS- 记录解析" class="headerlink" title="配置 DNS 记录解析"></a>配置 DNS 记录解析 </h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">A 记录</span></span><br><span class="line">example.org   A     10.2.3.4</span><br><span class="line">example.org   AAAA  2001:beef::1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">MX 记录</span></span><br><span class="line">example.org   MX    mx1.example.org.</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 同时最好配置 mx1.example.org 的 A 记录</span></span><br><span class="line">mx1.example.org   A     10.2.3.4</span><br><span class="line">mx1.example.org   AAAA  2001:beef::1</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">SPF</span></span><br><span class="line">example.org     TXT   &quot;v=spf1 mx ~all&quot;</span><br><span class="line">mx1.example.org TXT   &quot;v=spf1 mx ~all&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">_dmarc</span></span><br><span class="line">_dmarc.example.org   TXT    &quot;v=DMARC1; p=quarantine; ruf=mailto:postmaster@example.org&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">_mta-sts，_smtp.tls</span></span><br><span class="line">_mta-sts.example.org   TXT    &quot;v=STSv1; id=1&quot;</span><br><span class="line">_smtp._tls.example.org TXT    &quot;v=TLSRPTv1;rua=mailto:postmaster@example.org&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">_dmarc</span></span><br><span class="line">cd $(docker volume inspect maddydata --format &#x27;&#123;&#123;.Mountpoint&#125;&#125;&#x27;)</span><br><span class="line">cat dkim_keys/*.dns</span><br><span class="line"></span><br><span class="line">default._domainkey.example.org   TXT    &quot;v=DKIM1; k=ed25519; p=nAcUUozPlhc4VPhp7hZl+owES7j7OlEv0laaDEDBAqg=&quot;</span><br></pre></td></tr></table></figure><h3 id="创建邮件发送账户"><a href="# 创建邮件发送账户" class="headerlink" title="创建邮件发送账户"></a>创建邮件发送账户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it maddy sh</span><br><span class="line">maddyctl creds create postmaster@example.org</span><br><span class="line">maddyctl imap-acct create postmaster@example.org</span><br></pre></td></tr></table></figure><h2 id="备份"><a href="# 备份" class="headerlink" title="备份"></a>备份 </h2><p> 所有数据挂载在 volume 中，volum 路径为:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume inspect maddydata --format &#x27;&#123;&#123;.Mountpoint&#125;&#125;&#x27;</span><br><span class="line">/var/lib/docker/volumes/maddydata/_data</span><br><span class="line">$ cd /var/lib/docker/volumes/maddydata/_data</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>备份该目录即可</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> maddy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nginx 学习笔记</title>
      <link href="/posts/54644/"/>
      <url>/posts/54644/</url>
      
        <content type="html"><![CDATA[<h2 id="Nginx- 简介"><a href="#Nginx- 简介" class="headerlink" title="Nginx 简介"></a>Nginx 简介</h2><h3 id="Nginx- 是什么？"><a href="#Nginx- 是什么？" class="headerlink" title="Nginx 是什么？"></a>Nginx 是什么？</h3><p>Nginx (engine x) 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP&#x2F;POP3&#x2F;SMTP 服务器。Nginx 可以作为一个 Web 服务器进行网站的发布，也可以作为反向代理服务器进行负载均衡的实现。常见的 Web 服务器：Tomcat、Apache、Nginx、Weblogic 等</p><h3 id="特点"><a href="# 特点" class="headerlink" title="特点"></a>特点 </h3><p> 占用内存少、并发能力强</p><h2 id="搭建 -Nginx- 环境"><a href="# 搭建 -Nginx- 环境" class="headerlink" title="搭建 Nginx 环境"></a>搭建 Nginx 环境 </h2><h3 id="安装 -nginx"><a href="# 安装 -nginx" class="headerlink" title="安装 nginx"></a> 安装 nginx</h3><ul><li>源代码安装：需要编译.&#x2F;configure——&gt;make——&gt;make install</li><li>在线安装，参考：<a href="http://nginx.org/en/linux_packages.html">http://nginx.org/en/linux_packages.html</a></li></ul><h3 id="目录结构"><a href="# 目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><table><thead><tr><th align="left">目录</th><th align="left">路径</th></tr></thead><tbody><tr><td align="left">执行路径</td><td align="left">&#x2F;usr&#x2F;sbin&#x2F;nginx</td></tr><tr><td align="left">配置文件</td><td align="left">&#x2F;etc&#x2F;nginx&#x2F;nginx.conf</td></tr><tr><td align="left">日志目录</td><td align="left">&#x2F;var&#x2F;log&#x2F;nginx&#x2F;</td></tr><tr><td align="left">默认虚拟主机目录</td><td align="left">&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</td></tr></tbody></table><h3 id="相关命令"><a href="# 相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">netstat -ntpl | grep 80 #查看进程信息</span><br><span class="line">ps aux | grep nginx</span><br><span class="line">sudo nginx  #启动</span><br><span class="line">sudo nginx -s stop #停止</span><br><span class="line">sudo nginx -s reload  #重启</span><br><span class="line">sudo nginx -c /etc/nginx/nginx.conf  #使用指定的配置文件启动</span><br><span class="line">sudo nginx -t # 测试配置文件是否有错误</span><br><span class="line">sudo nginx -v #查看版本信息</span><br></pre></td></tr></table></figure><h3 id="关于配置文件"><a href="# 关于配置文件" class="headerlink" title="关于配置文件"></a>关于配置文件 </h3><p> 主配置文件 nginx.conf，包含三部分内容：全局配置、工作模式配置、HTTP 配置</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 运行 nginx 的用户</span></span><br><span class="line"><span class="attribute">user</span>  nginx;</span><br><span class="line"><span class="comment"># 工作进程的数量，可以根据 CPU 的核心总数来设置</span></span><br><span class="line">worker_processes  <span class="number">1</span>;</span><br><span class="line"><span class="comment"># 错误日志文件的位置及输出级别 error_log</span></span><br><span class="line">/var/log/nginx/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="comment">#PID 文件的位置</span></span><br><span class="line">pid        /var/run/nginx.pid;</span><br><span class="line"><span class="comment"># 工作模式配置</span></span><br><span class="line">events &#123;</span><br><span class="line">  <span class="comment"># 每个进程最大处理的连接数</span></span><br><span class="line">  <span class="attribute">worker_connections</span>  <span class="number">10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#HTTP 配置</span></span><br><span class="line">http &#123;</span><br><span class="line">  <span class="comment"># 支持的媒体类型</span></span><br><span class="line">  <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">  <span class="comment"># 默认的类型</span></span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line">  <span class="comment"># 日志格式</span></span><br><span class="line">  log_formatmain <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 访问日志文件的位置</span></span><br><span class="line">  access_log  /var/log/nginx/access.log  main;</span><br><span class="line">  <span class="comment"># 是否调用 sendfile 函数来输出文件</span></span><br><span class="line">  sendfile        <span class="literal">on</span>;</span><br><span class="line">  <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">  <span class="comment"># 连接超时时间</span></span><br><span class="line">  keepalive_timeout  <span class="number">65</span>;</span><br><span class="line">  <span class="comment"># 开启 gzip 压缩 #gzip  on;</span></span><br><span class="line">  <span class="comment"># 引入外部配置文件，包含虚拟主机的配置</span></span><br><span class="line">  include /etc/nginx/conf.d/<span class="regexp">*.conf</span>;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>虚拟主机配置文件 &#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf，可以定义多个虚拟主机配置文件</p><p>将原配置文件备份，养成数据备份的习惯</p><h2 id="HTTP- 服务器"><a href="#HTTP- 服务器" class="headerlink" title="HTTP 服务器"></a>HTTP 服务器 </h2><h3 id="虚拟主机"><a href="# 虚拟主机" class="headerlink" title="虚拟主机"></a> 虚拟主机 </h3><p> 把一台物理服务器划分为多个虚拟的服务器，称为虚拟主机。每个虚拟主机对应一个 Web 站点，其实就是在一台服务器上搭建多个网站</p><h3 id="步骤"><a href="# 步骤" class="headerlink" title="步骤"></a>步骤 </h3><p> 准备网站目录及测试页面</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /www/test1 /www/test2</span><br><span class="line">echo &#x27;test1&#x27; &gt; /www/test1/index.html</span><br><span class="line">echo &#x27;test2&#x27; &gt; /www/test2/index.html</span><br></pre></td></tr></table></figure><p>创建虚拟主机配置文件并配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/conf.d/</span><br><span class="line">sudo cp default.conf test1.conf</span><br><span class="line">sudo cp default.conf test2.conf</span><br></pre></td></tr></table></figure><p>sudo vim test1.conf</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  test1.ml2u.ml;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line">    <span class="comment">#access_log  /var/log/nginx/host.access.log  main;</span></span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">root</span>   /www/test1;</span><br><span class="line">        <span class="attribute">index</span>  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">    <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        <span class="attribute">root</span>   /usr/share/nginx/html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    proxy_pass   http://127.0.0.1;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">    <span class="comment">#    root           html;</span></span><br><span class="line">    <span class="comment">#    fastcgi_pass   127.0.0.1:9000;</span></span><br><span class="line">    <span class="comment">#    fastcgi_index  index.php;</span></span><br><span class="line">    <span class="comment">#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span></span><br><span class="line">    <span class="comment">#    include        fastcgi_params;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># deny access to .htaccess files, if Apache&#x27;s document root</span></span><br><span class="line">    <span class="comment"># concurs with nginx&#x27;s one</span></span><br><span class="line">    <span class="comment">#</span></span><br><span class="line">    <span class="comment">#location ~ /\.ht &#123;</span></span><br><span class="line">    <span class="comment">#    deny  all;</span></span><br><span class="line">    <span class="comment">#&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现虚拟主机的三种方式：</p><ul><li>基于不同的 IP</li><li>基于不同的端口</li><li>基于不同的域名</li></ul><p>配置域名解析 (这里以修改本地 host 文件为例子，实际使用需要购买域名)<br> 在客户端主机中配置域名解析</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Linux/Mac：/etc/hosts</span></span><br><span class="line"></span><br><span class="line">192.168.1.59 www.ums.com</span><br><span class="line">192.168.1.59 www.sms.com</span><br></pre></td></tr></table></figure><p>域名解析的过程：查找 hosts 文件——&gt;DNS</p><p>注：该方式仅是本地测试时使用的，实际应用中要购买注册域名</p><h3 id="作为图片服务器"><a href="# 作为图片服务器" class="headerlink" title="作为图片服务器"></a>作为图片服务器 </h3><p> 使用 Nginx 作为图片服务器：</p><p>上传：使用 ftp 或 sftp 上传图片到服务器指定的 ftp 目录下 <br> 下载：通过访问 Nginx 服务器来访问 ftp 目录下的图片文件，即使用 HTTP 请求来访问资源文件，而不是通过 FTP 请求 <br> 步骤：</p><p>创建存放图片的文件夹，并上传图片到该目录中 <br>mkdir &#x2F;home&#x2F;soft01&#x2F;www&#x2F;images<br> 配置 Nginx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/nginx/conf.d/default.conf</span><br><span class="line">    location /images &#123;</span><br><span class="line">      root   /home/soft01/www;</span><br><span class="line">      autoindex on; #打开目录浏览功能</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>访问 url：<a href="http://ip/images">http://ip/images</a></p><p>实际物理路径：&#x2F;home&#x2F;soft01&#x2F;www&#x2F;images</p><h2 id="反向代理"><a href="# 反向代理" class="headerlink" title="反向代理"></a>反向代理 </h2><h3 id="正向代理"><a href="# 正向代理" class="headerlink" title="正向代理"></a> 正向代理 </h3><p> 概念：位于客户端和原始服务器之间的服务器，为了从原始服务器获取数据，客户端向代理服务器发送请求并指定请求目标(原始服务器)，然后代理服务器将请求转换给原始服务器，并将响应的数据返回给客户端</p><p>正向代理是客户端使用的，对客户端进行代理，客户端知道并主动使用代理</p><p>作用：</p><ul><li>访问原来无法访问的资源（google、fackbook 等），翻墙</li><li>可以做缓存，加速资源的访问</li><li>对客户端上网进行认证授权</li><li>上网行为管理，记录用户访问记录，对外隐藏用户信息</li></ul><h3 id="反向代理 -1"><a href="# 反向代理 -1" class="headerlink" title="反向代理"></a>反向代理 </h3><h4 id="概念"><a href="# 概念" class="headerlink" title="概念"></a> 概念 </h4><p> 客户端发送请求到服务器（客户端认为是原始服务器，实际上是一台反向服务器），反向代理服务器接收请求并将请求转发给内部网络中的多台集群服务器，并将响应的数据返回给客户端反向代理一般用于服务器集群、分布式等，实现负载均衡</p><h4 id="作用"><a href="# 作用" class="headerlink" title="作用"></a>作用</h4><ul><li>负载均衡，提高处理和响应速度</li><li>保证内网的安全，隐藏服务器信息，防止 Web 攻击</li></ul><h4 id="配置"><a href="# 配置" class="headerlink" title="配置"></a>配置 </h4><p> 步骤：<br>创建虚拟主机配置文件，并配置反向代理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置 tomcat 代理</span></span><br><span class="line"><span class="section">upstream</span> tomcat &#123;</span><br><span class="line">       <span class="attribute">server</span> <span class="number">66.42.95.239:8080</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="section">server</span> &#123;</span><br><span class="line">     <span class="attribute">listen</span> <span class="number">80</span>;</span><br><span class="line">     <span class="attribute">server_name</span> tomcat.ml2u.ml;</span><br><span class="line">     <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="comment"># proxy_set_header        Host $host;</span></span><br><span class="line">        <span class="comment"># proxy_set_header        X-Real-IP $remote_addr;</span></span><br><span class="line">         <span class="attribute">proxy_pass</span> http://tomcat;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="负载均衡"><a href="# 负载均衡" class="headerlink" title="负载均衡"></a>负载均衡 </h2><h3 id="概念 -1"><a href="# 概念 -1" class="headerlink" title="概念"></a> 概念 </h3><p> 将接收到的请求按照一定的规则分发到不同的服务器进行处理，从而提高系统响应和处理速度，称为负载均衡</p><h3 id="配置 -1"><a href="# 配置 -1" class="headerlink" title="配置"></a>配置 </h3><p> 步骤：</p><p>准备网站（模拟淘宝，后面有多台服务器)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">拷贝两个 tomcat</span></span><br><span class="line"></span><br><span class="line">cp -r apache-tomcat-8.5.30 taobao1</span><br><span class="line">cp -r apache-tomcat-8.5.30 taobao2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">修改 tomcat 端口 </span></span><br><span class="line">vi taobao1/conf/server.xml</span><br><span class="line">vi taobao2/conf/server.xml</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 修改页面 </span></span><br><span class="line">vi taobao1/webapps/ROOT/index.jsp</span><br><span class="line">vi taobao2/webapps/ROOT/index.jsp</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"> 启动 tomcat</span></span><br><span class="line">./startup.s</span><br></pre></td></tr></table></figure><p>创建虚拟主机配置文件，并配置负载均衡</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo</span> cp proxy.conf taobao.conf</span><br><span class="line">sudo vi taobao.conf</span><br><span class="line"><span class="comment"># 后台服务器列表</span></span><br><span class="line"> upstream taobao_server&#123;</span><br><span class="line">      <span class="attribute">server</span> <span class="number">192.168.1.66:8081</span> weight=<span class="number">3</span>; <span class="comment">#weight 表示权重，权重越高被分配到的几率越大</span></span><br><span class="line">      server <span class="number">192.168.1.66:8082</span> weight=<span class="number">7</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> server &#123;</span><br><span class="line">      <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">      server_name  www.taobao.com;</span><br><span class="line">      location / &#123;</span><br><span class="line">          <span class="attribute">proxy_pass</span> http://taobao_server;  <span class="comment"># 指定代理的后台服务器      &#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="动静分离"><a href="# 动静分离" class="headerlink" title="动静分离"></a>动静分离 </h2><p> 问题：tomcat 在处理静态资源时效率不高，默认情况下所有资源都由 tomcat 处理，会导致 Web 应用响应慢，占用系统资源</p><p>解决：<br>将静态资源交由 Nginx 处理，动态资源仍由 tomcat 处理，实现动静分离</p><p>实际上就是把 Nginx 作为静态资源服务</p><p>配置步骤：</p><p>编辑 taobao.conf，配置动态分离</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /etc/nginx/conf.d/taobao.conf</span><br><span class="line">  #处理静态资源</span><br><span class="line">  location~ .*\.(js|css|ico|png|jpg|eot|svg|ttf|woff) &#123;</span><br><span class="line">      root /home/soft01/www/static;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建存放静态资源的文件夹，并将资源资源放到该目录中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cd /home/soft01/www</span><br><span class="line">mkdir staticcd static</span><br><span class="line">chmod777 *</span><br><span class="line">cd /home/soft01/software/taobao1/webapp/ROOT</span><br><span class="line">cp tomcat.css tomcat.png  /home/soft01/www/static</span><br></pre></td></tr></table></figure><p>高并发的处理：</p><ul><li>负载均衡：集群</li><li>动静分离：使用 Nginx、CDN</li><li>缓存：以空间换时间，提高系统效率</li><li>限流：流量控制</li><li>降级：服务降载</li></ul>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解 npm run 命令，run 命令的两条潜规则</title>
      <link href="/posts/41310/"/>
      <url>/posts/41310/</url>
      
        <content type="html"><![CDATA[<h2 id="1-npm-run"><a href="#1-npm-run" class="headerlink" title="1. npm run"></a>1. npm run</h2><p>npm 默认运行的 命令为 <code>npm run + script 名称</code>, 当 script 名称为<code>start</code> 时，<code>npm start</code> &#x3D; <code>npm run start</code><br>其他类似的命令还有</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm start === npm run start</span><br><span class="line">npm stop === npm run stop</span><br><span class="line">npm test === npm run test</span><br><span class="line">npm restart === npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start</span><br></pre></td></tr></table></figure><h2 id="2- 执行顺序"><a href="#2- 执行顺序" class="headerlink" title="2. 执行顺序"></a>2. 执行顺序 </h2><p> 一个 npm 脚本可以执行多个任务，这些任务之间可以指定不同的执行顺序。<br>对于单条命令 X，如果想并行运行多个，可以使用 <code>&amp;</code> 连接，如果想串行运行多个，可以使用 <code>&amp;&amp;</code> 连接。</p><h2 id="3- 顺序钩子"><a href="#3- 顺序钩子" class="headerlink" title="3. 顺序钩子"></a>3. 顺序钩子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;predev&quot;:&quot;node test_one.js&quot;,</span><br><span class="line">&quot;dev&quot;:&quot;node test_two.js&quot;,</span><br><span class="line">&quot;postdev&quot;:&quot;node test_three.js&quot;</span><br></pre></td></tr></table></figure><p>当执行 npm run dev 的时候默认就会执行:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run predev &amp;&amp; npm run dev &amp;&amp; npm run postdev</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>根据 docker 镜像反推 dockerfile</title>
      <link href="/posts/20922/"/>
      <url>/posts/20922/</url>
      
        <content type="html"><![CDATA[<p> 我们有时候想知道官方镜像的 dockerfile 是怎么写的，需要根据 docker image 反推 docker file<br> 命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">image=ubuntu:18.04</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker history $image --no-trunc \</span><br><span class="line">    --format &#x27;&#123;&#123;.CreatedBy&#125;&#125;&#x27;|\</span><br><span class="line">    sed &quot;s?/bin/sh\ -c\ \#(nop)\ ??g&quot;|\</span><br><span class="line">    sed &quot;s?/bin/sh\ -c?RUN?g&quot; |\</span><br><span class="line">    tac|\</span><br><span class="line">    tee Dockerfile</span><br></pre></td></tr></table></figure><p> 稍微解释一下命令的意思 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--no-trunc: 不截断输出 </span><br><span class="line">--format &#123;&#123;.CreatedBy&#125;&#125;: 格式化输出, 只输出 CreatedBy 字段 </span><br><span class="line">sed: 删除替换指定的字符串, 此处使用 `?` 作为 sed 的分隔符。常规 sed 分隔符为 `/` 或者 `#`</span><br><span class="line">tac: 将所有管道符号传来的内容反向输出 </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从 0 到 1：全面理解 RPC 远程调用</title>
      <link href="/posts/21358/"/>
      <url>/posts/21358/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="# 前言" class="headerlink" title="前言"></a>前言 </h2><p> 什么是 RPC 呢？</p><p>百度百科给出的解释是这样的：“RPC（Remote Procedure Call Protocol）——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议”。这个概念听起来还是比较抽象，没关系，继续往后看，后面概念性的东西，我会讲得足够清楚，让你完全掌握 RPC 的基础内容。在后面的篇章中还会结合其在 OpenStack 中实际应用，一步一步揭开 rpc 的神秘面纱。</p><p>有的读者，可能会问，为啥我举的例子老是 OpenStack 里的东西呢？</p><p>因为每个人的业务中接触的框架都不一样（我主要接触的就是 OpenStack 框架），我无法为每个人去定制写一篇文章，但其技术原理都是一样的。即使如此，我也会尽力将文章写得通用，不会因为你没接触过 OpenStack 而成为你理解 rpc 的瓶颈。</p><h2 id="既 -REST，何 -RPC-？"><a href="# 既 -REST，何 -RPC-？" class="headerlink" title="既 REST，何 RPC ？"></a>既 REST，何 RPC ？</h2><p>在 OpenStack 里的进程间通信方式主要有两种，一种是基于 HTTP 协议的 RESTFul API 方式，另一种则是 RPC 调用。</p><p>那么这两种方式在应用场景上有何区别呢？</p><p>有使用经验的人，就会知道：</p><ul><li>前者（RESTful）主要用于 <strong> 各组件之间 </strong> 的通信（如 nova 与 glance 的通信），或者说用于组件对外提供调用接口</li><li>而后者（RPC）则用于 <strong> 同一组件中各个不同模块之间 </strong> 的通信（如 nova 组件中 nova-compute 与 nova-scheduler 的通信）。</li></ul><p>关于 OpenStack 中基于 RESTful API 的通信方式主要是应用了 WSGI，这个知识点，我在前一篇文章中，有深入地讲解过，你可以点击查看。</p><p>对于不熟悉 OpenStack 的人，也别担心听不懂，这样吧，我给你提两个问题：</p><ol><li>RPC 和 REST 区别是什么？</li><li>为什么要采用 RPC 呢？</li></ol><h3 id="第一个问题：RPC- 和 -REST- 区别是什么？"><a href="# 第一个问题：RPC- 和 -REST- 区别是什么？" class="headerlink" title="第一个问题：RPC 和 REST 区别是什么？"></a><strong>第一个问题：RPC 和 REST 区别是什么？</strong></h3><p>你一定会觉得这个问题很奇怪，是的，包括我，但是你在网络上一搜，会发现类似对比的文章比比皆是，我在想可能很多初学者由于基础不牢固，才会将不相干的二者拿出来对比吧。既然是这样，那为了让你更加了解陌生的 RPC，就从你熟悉得不能再熟悉的 REST 入手吧。</p><h4 id="所属类别不同"><a href="# 所属类别不同" class="headerlink" title="所属类别不同"></a><strong>所属类别不同 </strong></h4><p>REST，是 Representational State Transfer 的简写，中文描述表述性状态传递（是指某个瞬间状态的资源数据的快照，包括资源数据的内容、表述格式(XML、JSON) 等信息。）</p><p>REST 是一种软件架构风格。 这种风格的典型应用，就是 HTTP。其因为简单、扩展性强的特点而广受开发者的青睐。</p><p>而 RPC 呢，是 Remote Procedure Call Protocol 的简写，中文描述是远程过程调用，它可以实现客户端像调用本地服务 (方法) 一样调用服务器的服务(方法)。</p><p>RPC 是一种基于 TCP 的通信协议，按理说它和 REST 不是一个层面上的东西，不应该放在一起讨论，但是谁让 REST 这么流行呢，它是目前最流行的一套互联网应用程序的 API 设计标准，某种意义下，我们说 REST 可以其实就是指代 HTTP 协议。</p><h4 id="使用方式不同"><a href="# 使用方式不同" class="headerlink" title="使用方式不同"></a><strong>使用方式不同 </strong></h4><p><strong> 从使用上来看</strong>，HTTP 接口只关注服务提供方，对于客户端怎么调用并不关心。接口只要保证有客户端调用时，返回对应的数据就行了。而 RPC 则要求客户端接口保持和服务端的一致。</p><ul><li>REST 是服务端把方法写好，客户端并不知道具体方法。客户端只想获取资源，所以发起 HTTP 请求，而服务端接收到请求后根据 URI 经过一系列的路由才定位到方法上面去</li><li>PRC 是服务端提供好方法给客户端调用，客户端需要知道服务端的具体类，具体方法，然后像调用本地方法一样直接调用它。</li></ul><h4 id="面向对象不同"><a href="# 面向对象不同" class="headerlink" title="面向对象不同"></a><strong>面向对象不同 </strong></h4><p> 从设计上来看，RPC，所谓的远程过程调用 ，是面向方法的 ，REST：所谓的 Representational state transfer ，是面向资源的，除此之外，还有一种叫做 SOA，所谓的面向服务的架构，它是面向消息的，这个接触不多，就不多说了。</p><h4 id="序列化协议不同"><a href="# 序列化协议不同" class="headerlink" title="序列化协议不同"></a><strong>序列化协议不同 </strong></h4><p> 接口调用通常包含两个部分，序列化和通信协议。</p><p>通信协议，上面已经提及了，REST 是 基于 HTTP 协议，而 RPC 可以基于 TCP&#x2F;UDP，也可以基于 HTTP 协议进行传输的。</p><p>常见的序列化协议，有：json、xml、hession、protobuf、thrift、text、bytes 等，REST 通常使用的是 JSON 或者 XML，而 RPC 使用的是 JSON-RPC，或者 XML-RPC。</p><p>通过以上几点，我们知道了 REST 和 RPC 之间有很明显的差异。</p><h3 id="第二个问题：为什么要采用 -RPC- 呢？"><a href="# 第二个问题：为什么要采用 -RPC- 呢？" class="headerlink" title="第二个问题：为什么要采用 RPC 呢？"></a><strong>第二个问题：为什么要采用 RPC 呢？</strong></h3><p>那到底为何要使用 RPC，单纯的依靠 RESTful API 不可以吗？为什么要搞这么多复杂的协议，渣渣表示真的学不过来了。</p><p>关于这一点，以下几点仅是我的个人猜想，仅供交流哈：</p><ol><li>RPC 和 REST 两者的定位不同，REST 面向资源，更注重接口的规范，因为要保证通用性更强，所以对外最好通过 REST。而 RPC 面向方法，主要用于函数方法的调用，可以适合更复杂通信需求的场景。</li><li>RESTful API 客户端与服务端之间采用的是同步机制，当发送 HTTP 请求时，客户端需要等待服务端的响应。当然对于这一点是可以通过一些技术来实现异步的机制的。</li><li>采用 RESTful API，客户端与服务端之间虽然可以独立开发，但还是存在耦合。比如，客户端在发送请求的时，必须知道服务器的地址，且必须保证服务器正常工作。而 rpc + ralbbimq 中间件可以实现低耦合的分布式集群架构。</li></ol><p>说了这么多，我们该如何选择这两者呢？我总结了如下两点，供你参考：</p><ul><li>REST 接口更加规范，通用适配性要求高，建议对外的接口都统一成 REST（也有例外，比如我接触过 zabbix，其 API 就是基于 JSON-RPC 2.0 协议的）。而组件内部的各个模块，可以选择 RPC，一个是不用耗费太多精力去开发和维护多套的 HTTP 接口，一个 RPC 的调用性能更高（见下条）</li><li>从性能角度看，由于 HTTP 本身提供了丰富的状态功能与扩展功能，但也正由于 HTTP 提供的功能过多，导致在网络传输时，需要携带的信息更多，从性能角度上讲，较为低效。而 RPC 服务网络传输上仅传输与业务内容相关的数据，传输数据更小，性能更高。</li></ul><h2 id="实现远程调用的三种方式"><a href="# 实现远程调用的三种方式" class="headerlink" title="实现远程调用的三种方式"></a>实现远程调用的三种方式</h2><p>“远程调用”意思就是：被调用方法的具体实现不在程序运行本地，而是在别的某个地方（分布到各个服务器），调用者只想要函数运算的结果，却不需要实现函数的具体细节。</p><h3 id="基于 -xml-rpc"><a href="# 基于 -xml-rpc" class="headerlink" title="基于 xml-rpc"></a>基于 xml-rpc</h3><h4 id="单线程"><a href="# 单线程" class="headerlink" title="单线程"></a>单线程</h4><p>Python 实现 rpc，可以使用标准库里的 SimpleXMLRPCServer，它是基于 XML-RPC 协议的。</p><p>有了这个模块，开启一个 rpc server，就变得相当简单了。执行以下代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">calculate</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x-y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x/y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">obj = calculate()</span><br><span class="line">server = SimpleXMLRPCServer.SimpleXMLRPCServer((<span class="string">&quot;localhost&quot;</span>, <span class="number">8088</span>))</span><br><span class="line"><span class="comment"># 将实例注册给 rpc server</span></span><br><span class="line">server.register_instance(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Listening on port 8088&quot;</span></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>有了 rpc server，接下来就是 rpc client，由于我们上面使用的是 XML-RPC，所以 rpc clinet 需要使用 xmlrpclib 这个库。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> xmlrpclib</span><br><span class="line"></span><br><span class="line">server = xmlrpclib.ServerProxy(<span class="string">&quot;http://localhost:8088&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后，我们通过 server_proxy 对象就可以远程调用之前的 rpc server 的函数了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; server.add(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.multiply(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.subtract(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>server.divide(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><p>SimpleXMLRPCServer 是一个单线程的服务器。这意味着，如果几个客户端同时发出多个请求，其它的请求就必须等待第一个请求完成以后才能继续。</p><h4 id="多线程"><a href="# 多线程" class="headerlink" title="多线程"></a>多线程 </h4><p> 若非要使用 SimpleXMLRPCServer 实现多线程并发，其实也不难。只要将代码改成如下即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> SimpleXMLRPCServer <span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"><span class="keyword">from</span> SocketServer <span class="keyword">import</span> ThreadingMixIn</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadXMLRPCServer</span>(ThreadingMixIn, SimpleXMLRPCServer):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyObject</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello xmlprc&quot;</span></span><br><span class="line"></span><br><span class="line">obj = MyObject()</span><br><span class="line">server = ThreadXMLRPCServer((<span class="string">&quot;localhost&quot;</span>, <span class="number">8088</span>), allow_none=<span class="literal">True</span>)</span><br><span class="line">server.register_instance(obj)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Listening on port 8088&quot;</span></span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><h3 id="基于 -json-rpc"><a href="# 基于 -json-rpc" class="headerlink" title="基于 json-rpc"></a>基于 json-rpc</h3><p>SimpleXMLRPCServer 是基于 xml-rpc 实现的远程调用，上面我们也提到 除了 xml-rpc 之外，还有 json-rpc 协议。</p><p>那 python 如何实现基于 json-rpc 协议呢？</p><p>答案是很多，很多 web 框架其自身都自己实现了 json-rpc，但我们要独立这些框架之外，要寻求一种较为干净的解决方案，我查找到的选择有两种， <code>jsonrpclib</code>和<code>python-jsonrpc</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install jsonrpclib -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install python-jsonrpc -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><h4 id="先来看第一种 -jsonrpclib"><a href="# 先来看第一种 -jsonrpclib" class="headerlink" title="先来看第一种 jsonrpclib"></a>先来看第一种 <a href="https://github.com/joshmarshall/jsonrpclib/">jsonrpclib</a></h4><p>它与 Python 标准库的 SimpleXMLRPCServer 很类似（因为它的类名就叫做 SimpleJSONRPCServer ，不明真相的人真以为它们是亲兄弟）。或许可以说，jsonrpclib 就是仿照 SimpleXMLRPCServer 标准库来进行编写的。</p><p>它的导入与 SimpleXMLRPCServer 略有不同，因为 SimpleJSONRPCServer 分布在 jsonrpclib 库中。</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> jsonrpclib.SimpleJSONRPCServer <span class="keyword">import</span> SimpleJSONRPCServer</span><br><span class="line"></span><br><span class="line">server = SimpleJSONRPCServer((<span class="string">&#x27;localhost&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">server.register_function(<span class="keyword">lambda</span> x,y: x+y, <span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonrpclib</span><br><span class="line"></span><br><span class="line">server = jsonrpclib.Server(<span class="string">&quot;http://localhost:8080&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="再来看第二种 -python-jsonrpc"><a href="# 再来看第二种 -python-jsonrpc" class="headerlink" title="再来看第二种 python-jsonrpc"></a>再来看第二种 python-jsonrpc</h4><p>写起来貌似有些复杂。</p><p>服务端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyjsonrpc</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RequestHandler</span>(pyjsonrpc.HttpRequestHandler):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @pyjsonrpc.rpcmethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, a, b</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;Test method&quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line"></span><br><span class="line">http_server = pyjsonrpc.ThreadingHttpServer(</span><br><span class="line">    server_address=(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">8080</span>),</span><br><span class="line">    RequestHandlerClass=RequestHandler</span><br><span class="line">)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;Starting HTTP server ...&quot;</span></span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;URL: http://localhost:8080&quot;</span></span><br><span class="line">http_server.serve_forever()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyjsonrpc</span><br><span class="line"></span><br><span class="line">http_client = pyjsonrpc.HttpClient(</span><br><span class="line">    url=<span class="string">&quot;http://localhost:8080/jsonrpc&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还记得上面我提到过的 zabbix API，因为我有接触过，所以也拎出来讲讲。zabbix API 也是基于 json-rpc 2.0 协议实现的。</p><p>因为内容较多，这里只带大家打个，zabbix 是如何调用的：直接指明要调用 zabbix server 的哪个方法，要传给这个方法的参数有哪些。</p><h3 id="基于 -zerorpc"><a href="# 基于 -zerorpc" class="headerlink" title="基于 zerorpc"></a>基于 zerorpc</h3><p>以上介绍的两种 rpc 远程调用方式，如果你足够细心，可以发现他们都是 http+rpc 两种协议结合实现的。</p><p>接下来，我们要介绍的这种（<a href="https://github.com/0rpc/zerorpc-python">zerorpc</a>），就不再使用走 http 了。</p><p><a href="https://github.com/0rpc/zerorpc-python">zerorpc</a> 这个第三方库，它是基于 TCP 协议、 ZeroMQ 和 MessagePack 的，速度相对快，响应时间短，并发高。zerorpc 和 pyjsonrpc 一样，需要额外安装，而 SimpleXMLRPCServer 不需要额外安装，但是性能相对差一些。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install zerorpc -i https://pypi.douban.com/simple</span><br></pre></td></tr></table></figure><p>服务端代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">caculate</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">hello</span>(<span class="params">self, name</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;hello, &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">subtract</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(x-y)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">divide</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        <span class="keyword">return</span> x/y</span><br><span class="line"></span><br><span class="line">s = zerorpc.Server(caculate())</span><br><span class="line"></span><br><span class="line">s.bind(<span class="string">&quot;tcp://0.0.0.0:4242&quot;</span>)</span><br><span class="line">s.run()</span><br></pre></td></tr></table></figure><p>客户端</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zerorpc</span><br><span class="line"></span><br><span class="line">c = zerorpc.Client()</span><br><span class="line">c.connect(<span class="string">&quot;tcp://127.0.0.1:4242&quot;</span>)</span><br></pre></td></tr></table></figure><p>客户端除了可以使用 zerorpc 框架实现代码调用之外，它还支持使用“命令行”的方式调用。</p><p>客户端可以使用命令行，那服务端是不是也可以呢？</p><p>是的，通过 Github 上的文档几个 demo 可以体验到这个第三方库做真的是优秀。</p><p>比如我们可以用下面这个命令，创建一个 rpc server，后面这个 <code>time</code> Python 标准库中的 time 模块，zerorpc 会将 time 注册绑定以供 client 调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zerorpc --server --bind tcp://127.0.0.1:1234 time</span><br></pre></td></tr></table></figure><p>在客户端，就可以用这条命令来远程调用这个 time 函数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zerorpc --client --connect tcp://127.0.0.1:1234 strftime %Y/%m/%d</span><br></pre></td></tr></table></figure><h2 id="往 -rpc- 中引入消息中间件"><a href="# 往 -rpc- 中引入消息中间件" class="headerlink" title="往 rpc 中引入消息中间件"></a>往 rpc 中引入消息中间件 </h2><p> 经过了上面的学习，我们已经学会了如何使用多种方式实现 rpc 远程调用。</p><p>通过对比，zerorpc 可以说是脱颖而出，一支独秀。</p><p>但为何在 OpenStack 中，rpc client 不直接 rpc 调用 rpc server ，而是先把 rpc 调用请求发给 RabbitMQ ，再由订阅者（rpc server）来取消息，最终实现远程调用呢？</p><p>为此，我也做了一番思考：</p><p>OpenStack 组件繁多，在一个较大的集群内部每个组件内部通过 rpc 通信频繁，如果都采用 rpc 直连调用的方式，连接数会非常地多，开销大，若有些 server 是单线程的模式，超时会非常的严重。</p><p>OpenStack 是复杂的分布式集群架构，会有多个 rpc server 同时工作，假设有 server01，server02，server03 三个 server，当 rpc client 要发出 rpc 请求时，发给哪个好呢？这是问题一。</p><p>你可能会说轮循或者随机，这样对大家都公平。这样的话还会引出另一个问题，倘若请求刚好发到 server01，而 server01 刚好不凑巧，可能由于机器或者其他因为导致服务没在工作，那这个 rpc 消息可就直接失败了呀。要知道做为一个集群，高可用是基本要求，如果出现刚刚那样的情况其实是很尴尬的。这是问题二。</p><p>集群有可能根据实际需要扩充节点数量，如果使用直接调用，耦合度太高，不利于部署和生产。这是问题三。</p><p>引入消息中间件，可以很好的解决这些问题。</p><p><strong>解决问题一</strong>：消息只有一份，接收者由 AMQP 的负载算法决定，默认为在所有 Receiver 中均匀发送(round robin)。</p><p><strong>解决问题二</strong>：有了消息中间件做缓冲站，client 可以任性随意的发，server 都挂掉了？没有关系，等 server 正常工作后，自己来消息中间件取就行了。</p><p><strong>解决问题三</strong>：无论有多少节点，它们只要认识消息中间件这一个中介就足够了。</p><h2 id="消息队列你应该知道什么？"><a href="# 消息队列你应该知道什么？" class="headerlink" title="消息队列你应该知道什么？"></a>消息队列你应该知道什么？</h2><p>由于后面，我将实例讲解 OpenStack 中如何将 rpc 和 mq broker 结合使用。</p><p>而在此之前，你必须对消息队列的一些基本知识有个概念。</p><p>首先，RPC 只是定义了一个通信接口，其底层的实现可以各不相同，可以是 socket，也可以是今天要讲的 AMQP。</p><p>AMQP(Advanced Message Queuing Protocol)是一种基于队列的可靠消息服务协议，作为一种通信协议，AMQP 同样存在多个实现，如 Apache Qpid，RabbitMQ 等。</p><p>以下是 AMQP 中的几个必知的概念：</p><ul><li><p>Publisher：消息发布者</p></li><li><p>Receiver：消息接收者，在 RabbitMQ 中叫订阅者：Subscriber。</p></li><li><p>Queue：用来保存消息的存储空间，消息没有被 receive 前，保存在队列中。</p></li><li><p>Exchange：用来接收 Publisher 发出的消息，根据 Routing key 转发消息到对应的 Message Queue 中，至于转到哪个队列里，这个路由算法又由 exchange type 决定的。</p><p>exchange type：主要四种描述 exchange 的类型。</p><p>direct：消息路由到满足此条件的队列中(queue, 可以有多个)： routing key &#x3D; binding key</p><p>topic：消息路由到满足此条件的队列中(queue, 可以有多个)：routing key 匹配 binding pattern. binding pattern 是类似正则表达式的字符串，可以满足复杂的路由条件。</p><p>fanout：消息路由到多有绑定到该 exchange 的队列中。</p></li><li><p>binding ：binding 是用来描述 exchange 和 queue 之间的关系的概念，一个 exchang 可以绑定多个队列，这些关系由 binding 建立。前面说的 binding key &#x2F;binding pattern 也是在 binding 中给出。</p></li></ul><p>在网上找了个图，可以很清晰地描述几个名词的关系。</p><p>关于 AMQP，有几下几点值得注意：</p><ol><li>每个 receiver&#x2F;subscriber 在接收消息前都需要创建 binding。</li><li>一个队列可以有多个 receiver，队列里的一个消息只能发给一个 receiver。</li><li>一个消息可以被发送到一个队列中，也可以被发送到多个多列中。多队列情况下，一个消息可以被多个 receiver 收到并处理。Openstack RPC 中这两种情况都会用到。</li></ol><h2 id="OpenStack- 中如何使用 -RPC？"><a href="#OpenStack- 中如何使用 -RPC？" class="headerlink" title="OpenStack 中如何使用 RPC？"></a>OpenStack 中如何使用 RPC？</h2><p>前面铺垫了那么久，终于到了讲真实应用的场景。在生产中 RPC 是如何应用的呢？</p><p>其他模型我不太清楚，在 OpenStack 中的应用模型是这样的</p><p>至于为什么要如此设计，前面我已经给出了自己的观点。</p><p>接下来，就是源码解读 OpenStack ，看看其是如何通过 rpc 进行远程调用的。如若你对此没有兴趣（我知道很多人对此都没有兴趣，所以不浪费大家时间），可以直接跳过这一节，进入下一节。</p><p>目前 Openstack 中有两种 RPC 实现，一种是在 oslo messaging, 一种是在 openstack.common.rpc。</p><p>openstack.common.rpc 是旧的实现，oslo messaging 是对 openstack.common.rpc 的重构。openstack.common.rpc 在每个项目中都存在一份拷贝，oslo messaging 即将这些公共代码抽取出来，形成一个新的项目。oslo messaging 也对 RPC API 进行了重新设计，对多种 transport 做了进一步封装，底层也是用到了 kombu 这个 AMQP 库。（注：Kombu 是 Python 中的 messaging 库。Kombu 旨在通过为 AMQ 协议提供惯用的高级接口，使 Python 中的消息传递尽可能简单，并为常见的消息传递问题提供经过验证和测试的解决方案。）</p><p>关于 oslo_messaging 库，主要提供了两种独立的 API:</p><ol><li>oslo.messaging.rpc(实现了客户端 - 服务器远程过程调用）</li><li>oslo.messaging.notify（实现了事件的通知机制）</li></ol><p>因为 notify 实现是太简单了，所以这里我就不多说了，如果有人想要看这方面内容，可以收藏我的博客(<a href="http://python-online.cn/">http://python-online.cn</a>) ，我会更新补充 notify 的内容。</p><p>OpenStack RPC 模块提供了 rpc.call，rpc.cast, rpc.fanout_cast 三种 RPC 调用方法，发送和接收 RPC 请求。</p><ul><li>rpc.call 发送 RPC <strong>同步请求 </strong> 并返回请求处理结果。</li><li>rpc.cast 发送 RPC <strong>异步请求</strong>，与 rpc.call 不同之处在于，不需要请求处理结果的返回。</li><li>rpc.fanout_cast 用于发送 RPC 广播信息无返回结果</li></ul><p>rpc.call 和 rpc.rpc.cast 从实现代码上看，他们的区别很小，就是 call 调用时候会带有 wait_for_reply&#x3D;True 参数，而 cast 不带。</p><p>要了解 rpc 的调用机制呢，首先要知道 oslo_messaging 的几个概念</p><ul><li><p>transport：RPC 功能的底层实现方法，这里是 rabbitmq 的消息队列的访问路径</p><p>transport 就是定义你如何访连接消息中间件，比如你使用的是 Rabbitmq，那在 nova.conf 中应该有一行 <code>transport_url</code> 的配置，可以很清楚地看出指定了 rabbitmq 为消息中间件，并配置了连接 rabbitmq 的 user，passwd，主机，端口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">transport_url=rabbit://user:passwd@host:<span class="number">5672</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_transport</span>(<span class="params">conf, url=<span class="literal">None</span>, allowed_remote_exmods=<span class="literal">None</span></span>):</span><br><span class="line">  <span class="keyword">return</span> _get_transport(conf, url, allowed_remote_exmods,</span><br><span class="line">                        transport_cls=RPCTransport)</span><br></pre></td></tr></table></figure></li><li><p>target：指定 RPC topic 交换机的匹配信息和绑定主机。</p><p>target 用来表述 RPC 服务器监听 topic，server 名称和 server 监听的 exchange，是否广播 fanout。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Target</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, exchange=<span class="literal">None</span>, topic=<span class="literal">None</span>, namespace=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 version=<span class="literal">None</span>, server=<span class="literal">None</span>, fanout=<span class="literal">None</span>,</span></span><br><span class="line"><span class="params">                 legacy_namespaces=<span class="literal">None</span></span>):</span><br><span class="line">        self.exchange = exchange</span><br><span class="line">        self.topic = topic</span><br><span class="line">        self.namespace = namespace</span><br><span class="line">        self.version = version</span><br><span class="line">        self.server = server</span><br><span class="line">        self.fanout = fanout</span><br><span class="line">        self.accepted_namespaces = [namespace] + (legacy_namespaces <span class="keyword">or</span> [])</span><br></pre></td></tr></table></figure><p>rpc server 要获取消息，需要定义 target，就像一个门牌号一样。</p><p>rpc client 要发送消息，也需要有 target，说明消息要发到哪去。</p></li><li><p>endpoints：是可供别人远程调用的对象</p><p>RPC 服务器暴露出 endpoint，每个 endpoint 包涵一系列的可被远程客户端通过 transport 调用的方法。直观理解，可以参考 nova-conductor 创建 rpc server 的代码，这边的 endpoints 就是 <code>nova/manager.py:ConductorManager()</code></p></li><li><p>dispatcher：分发器，这是 rpc server 才有的概念。只有通过它 server 端才知道接收到的 rpc 请求，要交给谁处理，怎么处理？</p><p>在 client 端，是这样指定要调用哪个方法的。</p><p>而在 server 端，是如何知道要执行这个方法的呢？这就是 dispatcher 要干的事，它从 endpoint 里找到这个方法，然后执行，最后返回。</p></li><li><p>Serializer：在 python 对象和 message(notification) 之间数据做序列化或是反序列化的基类。</p><p>主要方法有四个：</p><ol><li>deserialize_context(ctxt) ：对字典变成 request contenxt.</li><li>deserialize_entity(ctxt, entity) ：对 entity 做反序列化，其中 ctxt 是已经 deserialize 过的，entity 是要处理的。</li><li>serialize_context(ctxt) ：将 Request context 变成字典类型</li><li>serialize_entity(ctxt, entity) ：对 entity 做序列化，其中 ctxt 是已经 deserialize 过的，entity 是要处理的。</li></ol></li><li><p>executor：服务的运行方式，单线程或者多线程</p><p>每个 notification listener 都和一个 executor 绑定，来控制收到的 notification 如何分配。默认情况下，使用的是 blocking executor(具体特性参加 executor 一节）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">oslo_messaging.get_notification_listener(transport, targets, endpoints, executor=’blocking’, serializer=<span class="literal">None</span>, allow_requeue=<span class="literal">False</span>, pool=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure></li></ul><p>rpc server 和 rpc client 的四个重要方法</p><ol><li><code>reset()</code>：Reset service.</li><li><code>start()</code>：该方法调用后，server 开始 poll, 从 transport 中接收 message, 然后转发给 dispatcher. 该 message 处理过程一直进行，直到 stop 方法被调用。executor 决定 server 的 IO 处理策略。可能会是用一个新进程、新协程来做 poll 操作，或是直接简单的在一个循环中注册一个回调。同样，executor 也决定分配 message 的方式，是在一个新线程中 dispatch 或是….. *</li><li><code>stop()</code>: 当调用 stop 之后，新的 message 不会被处理。但是，server 可能还在处理一些之前没有处理完的 message, 并且底层 driver 资源也还一直没有释放。</li><li><code>wait()</code>：在 stop 调用之后，可能还有 message 正在被处理，使用 wait 方法来阻塞当前进程，直到所有的 message 都处理完成。之后，底层的 driver 资源会释放。</li></ol><h2 id="06- 模仿 -OpenStack- 写 -rpc- 调用"><a href="#06- 模仿 -OpenStack- 写 -rpc- 调用" class="headerlink" title="06. 模仿 OpenStack 写 rpc 调用"></a>06. 模仿 OpenStack 写 rpc 调用 </h2><p> 模仿是一种很高效的学习方法，我这里根据 OpenStack 的调用方式，抽取出核心内容，写成一个简单的 demo，有对 OpenStack 感兴趣的可以了解一下，<strong>大部分人也可以直接跳过这章节</strong>。</p><p>以下代码不能直接运行，你还需要配置 rabbitmq 的连接方式，你可以写在配置文件中，通过 get_transport 从 cfg.CONF 中读取，也可以直接将其写成 url 的格式做成参数，传给 get_transport 。</p><p><strong>简单的 rpc client</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> oslo_messaging</span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 rpc client</span></span><br><span class="line">transport = oslo_messaging.get_transport(cfg.CONF, url=<span class="string">&quot;&quot;</span>)</span><br><span class="line">target = oslo_messaging.Target(topic=<span class="string">&#x27;test&#x27;</span>, version=<span class="string">&#x27;2.0&#x27;</span>)</span><br><span class="line">client = oslo_messaging.RPCClient(transport, target)</span><br><span class="line"></span><br><span class="line"><span class="comment"># rpc 同步调用</span></span><br><span class="line">client.call(ctxt, <span class="string">&#x27;test&#x27;</span>, arg=arg)</span><br></pre></td></tr></table></figure><p><strong>简单的 rpc server</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> oslo_config <span class="keyword">import</span> cfg</span><br><span class="line"><span class="keyword">import</span> oslo_messaging</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义 endpoint 类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ServerControlEndpoint</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    target = oslo_messaging.Target(namespace=<span class="string">&#x27;control&#x27;</span>,</span><br><span class="line">                                   version=<span class="string">&#x27;2.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server</span>):</span><br><span class="line">        self.server = server</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">stop</span>(<span class="params">self, ctx</span>):</span><br><span class="line">        <span class="keyword">if</span> self.server:</span><br><span class="line">            self.server.stop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TestEndpoint</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">self, ctx, arg</span>):</span><br><span class="line">        <span class="keyword">return</span> arg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 rpc server</span></span><br><span class="line">transport = oslo_messaging.get_transport(cfg.CONF, url=<span class="string">&quot;&quot;</span>)</span><br><span class="line">target = oslo_messaging.Target(topic=<span class="string">&#x27;test&#x27;</span>, server=<span class="string">&#x27;server1&#x27;</span>)</span><br><span class="line">endpoints = [</span><br><span class="line">    ServerControlEndpoint(<span class="literal">None</span>),</span><br><span class="line">    TestEndpoint(),</span><br><span class="line">]</span><br><span class="line">server = oslo_messaging.get_rpc_server(transport, target,endpoints,executor=<span class="string">&#x27;blocking&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    server.start()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Stopping server&quot;</span>)</span><br><span class="line"></span><br><span class="line">server.stop()</span><br><span class="line">server.wait()</span><br></pre></td></tr></table></figure><p>以上，就是本期推送的全部内容，周末两天没有出门，都在写这篇文章。真的快掏空了我自己，不过写完后真的很畅快。</p><blockquote><p>本文转载自 <a href="https://www.cnblogs.com/wongbingming/p/11086773.html">https://www.cnblogs.com/wongbingming/p/11086773.html</a></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> rpc </tag>
            
            <tag> openstack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 8 个实用的“无代码”特性</title>
      <link href="/posts/52155/"/>
      <url>/posts/52155/</url>
      
        <content type="html"><![CDATA[<h2 id="Python-CLI-“-m”- 参数"><a href="#Python-CLI-“-m”- 参数" class="headerlink" title="Python CLI “-m” 参数"></a>Python CLI “-m” 参数 </h2><p>python 的<code>-m mod</code> 参数，它会将 Python 模块以脚本的形式运行。因此，如果该模块的实现支持命令行操作，我们就可以在命令行直接使用它。</p><h3 id="服务端口测试"><a href="# 服务端口测试" class="headerlink" title="服务端口测试"></a>服务端口测试</h3><blockquote><p>telnetlib 模块</p></blockquote><p>测试对端服务器端口是否开放</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m telnetlib -d localhost 22</span><br></pre></td></tr></table></figure><p>结果如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Telnet(localhost,22): recv b&#x27;SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.4\r\n&#x27;</span><br><span class="line">SSH-2.0-OpenSSH_8.2p1 Ubuntu-4ubuntu0.4</span><br><span class="line"></span><br><span class="line">Telnet(localhost,22): send b&#x27;\n&#x27;</span><br><span class="line">Telnet(localhost,22): recv b&#x27;Invalid SSH identification string.\r\n&#x27;</span><br><span class="line">Invalid SSH identification string.</span><br><span class="line">Telnet(localhost,22): recv b&#x27;&#x27;</span><br><span class="line">*** Connection closed by remote host ***</span><br></pre></td></tr></table></figure><h3 id="本地启动 -web- 服务"><a href="# 本地启动 -web- 服务" class="headerlink" title="本地启动 web 服务"></a>本地启动 web 服务</h3><blockquote><p>http.server 模块</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">❯ python -m http.server --help</span><br><span class="line">usage: server.py [-h] [--cgi] [--bind ADDRESS] [--directory DIRECTORY] [port]</span><br><span class="line">❯ python -m http.server</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 (http://0.0.0.0:8000/) ...</span><br><span class="line">150.132.93.4 - - [20/Apr/2022 11:02:47] &quot;GET / HTTP/1.1&quot; 200 -</span><br><span class="line">150.132.93.4 - - [20/Apr/2022 11:02:47] code 404, message File not found</span><br><span class="line">150.132.93.4 - - [20/Apr/2022 11:02:47] &quot;GET /favicon.ico HTTP/1.1&quot; 404 -</span><br></pre></td></tr></table></figure><p>Note: 请勿在当前用户 home 目录起 http.server, 以免密钥丢失</p><h3 id="验证及格式化 -JSON- 字符串"><a href="# 验证及格式化 -JSON- 字符串" class="headerlink" title="验证及格式化 JSON 字符串"></a>验证及格式化 JSON 字符串</h3><blockquote><p>json.tool</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &#x27;&#123;&quot;name&quot;: &#123;&quot;first_name&quot;:&quot;Chris&quot;, &quot;last_name&quot;:&quot;Tao&quot;&#125;, &quot;age&quot;:33&#125;&#x27; | python3 -m json.tool</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &#123;</span><br><span class="line">        &quot;first_name&quot;: &quot;Chris&quot;,</span><br><span class="line">        &quot;last_name&quot;: &quot;Tao&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;age&quot;: 33</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建文本编辑器"><a href="# 创建文本编辑器" class="headerlink" title="创建文本编辑器"></a>创建文本编辑器</h3><blockquote><p>idlelib 模块</p></blockquote><p>临时替代代码编辑工具，代码是支持语法高亮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir get_time_app</span><br><span class="line">python -m idlelib get_time_app/print_time.py</span><br></pre></td></tr></table></figure><p>如果文件目录不存在，<code>idlelib</code>将无法创建，因此如果必要，我们需要创建一个。我们运行完这个命令之后，print_time.py 只有执行保存的情况下才会创建到本地。现在应该会弹出编辑器，我们可以在里面写一些代码， 可以看到代码是支持语法高亮的。</p><h3 id="创建可执行应用程序"><a href="# 创建可执行应用程序" class="headerlink" title="创建可执行应用程序"></a>创建可执行应用程序</h3><blockquote><p>zipapp</p></blockquote><p>如果我们想要创建一个简单的应用，比如前面写的获取当前时间的应用程序，我们不必再需要像 PyInstaller 这样的第三方工具包，Python 内置的 Zipapp 就可以做到。假设我们要打包成一个”Get Time”的应用，我们可以在命令行运行下面的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipapp get_time_app -m &quot;print_time:main&quot;</span><br></pre></td></tr></table></figure><p>在该命令中，我们只需要给 <code>zipapp</code>设置 <code>get_time_app</code> 名称，指定 Python 程序的入口文件及其程序入口函数即可。以 <code>.pyz</code> 为扩展名的文件就是我们创建的应用程序，至此我们就可以将项目作为单个文件而不是文件夹进行分发。</p><p>该程序的启动方式也很简单，直接使用 Python 进行调用即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python get_time_app.pyz</span><br></pre></td></tr></table></figure><h3 id="编码和解码字符串或文件"><a href="# 编码和解码字符串或文件" class="headerlink" title="编码和解码字符串或文件"></a>编码和解码字符串或文件</h3><blockquote><p>base64, encodings.rot_13</p></blockquote><p>通过 Python CLI，我们可以加密字符串或文件。我们以有趣的 ROT13 加密算法为例进行展示。ROT13 是一种偏移 13 位的凯撒密码，它的加密原理如下图所示。</p><p>使用 <code>encodings.rot_13</code> 来加密一个字符串，命令如下。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &quot;I am Chris&quot; | python -m encodings.rot_13</span><br><span class="line">V nz Puevf</span><br></pre></td></tr></table></figure><p>切记，不要将其用于任何真正的加密内容。因为英文有 26 个字母，所以再次运行这个算法我们可以很容易地破译这个加密字符串:)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &#x27;V nz Puevf&#x27; | python -m encodings.rot_13</span><br><span class="line">I am Chris</span><br></pre></td></tr></table></figure><p>base64 编码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &quot;I am Chris&quot; | python -m base64</span><br><span class="line">SSBhbSBDaHJpcwo=</span><br></pre></td></tr></table></figure><p>base64 解码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ echo &quot;SSBhbSBDaHJpcwo=&quot; | python -m base64 -d</span><br><span class="line">I am Chris</span><br></pre></td></tr></table></figure><p>base64 也经常用在对图像文件的编码和解码上。我们也可以对文件进行如下编码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m base64 get_time_app/print_time.py</span><br></pre></td></tr></table></figure><p>非常有趣的是，解码后的 Python 脚本可以即时执行，不会报错。。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;ZnJvbSBkYXRldGltZSBpbXBvcnQgZGF0ZXRpbWUKCgpkZWYgbWFpbigpOgogICAgY3VycmVudF90aW1lID0gZGF0ZXRpbWUubm93KCkKICAgIHByaW50KGYnQ3VycmVudCB0aW1lIGlzIHtjdXJyZW50X3RpbWV9LicpCgoKaWYgX19uYW1lX18gPT0gJ19fbWFpbl9fJzoKICAgIG1haW4oKQo=&quot; | python -m base64 -d | python</span><br></pre></td></tr></table></figure><h3 id="获取系统元数据"><a href="# 获取系统元数据" class="headerlink" title="获取系统元数据"></a>获取系统元数据</h3><blockquote><p>sysconfig, site 模块</p></blockquote><p>获取当前的系统信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m sysconfig</span><br></pre></td></tr></table></figure><p>获取 Python 环境路径和当前工作路径</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m site</span><br></pre></td></tr></table></figure><h3 id="文件压缩解压"><a href="# 文件压缩解压" class="headerlink" title="文件压缩解压"></a>文件压缩解压</h3><blockquote><p>压缩文件，替代 tar&#x2F;zip&#x2F;gzip 等工具</p></blockquote><h4 id="压缩"><a href="# 压缩" class="headerlink" title="压缩"></a>压缩</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipfile -c get_time_app.zip get_time_app</span><br></pre></td></tr></table></figure><h4 id="解压"><a href="# 解压" class="headerlink" title="解压"></a>解压</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m zipfile -e get_time_app.zip get_time_app_extracted</span><br></pre></td></tr></table></figure><p>我们刚刚以 zip 文件为例进行了展示，Python 除了支持 zip 格式的解压缩以外，还支持 tar 和 gzip 的解压缩。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地 git 仓库链接远程仓库</title>
      <link href="/posts/42816/"/>
      <url>/posts/42816/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以 github 仓库为例，当远程仓库已经创建</p></blockquote><h2 id="1- 初始化本地仓库"><a href="#1- 初始化本地仓库" class="headerlink" title="1. 初始化本地仓库"></a>1. 初始化本地仓库</h2><h3 id="1-1-git-init- 时设定 -branch- 为 -main"><a href="#1-1-git-init- 时设定 -branch- 为 -main" class="headerlink" title="1.1 git init 时设定 branch 为 main"></a>1.1 git init 时设定 branch 为 main</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init -b main</span><br></pre></td></tr></table></figure><p>也可以在 gitconfig 里配置默认值，要求 git 版本大于 2.28</p><h3 id="1-2-Ubuntu- 升级 -git- 版本"><a href="#1-2-Ubuntu- 升级 -git- 版本" class="headerlink" title="1.2 Ubuntu 升级 git 版本"></a>1.2 Ubuntu 升级 <a href="https://git-scm.com/download/linux">git 版本</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">For Ubuntu, this PPA provides the latest stable upstream Git version</span></span><br><span class="line">add-apt-repository ppa:git-core/ppa</span><br><span class="line">apt update &amp;&amp; apt install git</span><br></pre></td></tr></table></figure><span id="more"></span><p>设置默认为 main branch</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure><p>查看配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">❯ cat ~/.gitconfig</span><br><span class="line">[include]</span><br><span class="line">        path = /etc/git-setup/gitconfig</span><br><span class="line">[core]</span><br><span class="line">        editor = vi</span><br><span class="line">[user]</span><br><span class="line">        name =</span><br><span class="line">        email =</span><br><span class="line">[merge]</span><br><span class="line">        tool = vimdiff</span><br><span class="line">[alias]</span><br><span class="line">co = checkout</span><br><span class="line">ci = commit</span><br><span class="line">st = status</span><br><span class="line">br = branch</span><br><span class="line">hist = log --graph --format=format:\&quot;%C(red)%h%C(reset) %C(yellow)%cd%C(reset) | %s %C(green)\\[%an\\]%C(reset)%C(bold blue)%d%C(reset)\&quot; --abbrev-commit --date=short</span><br><span class="line">root = rev-parse --show-toplevel</span><br><span class="line">alias = !git config --list | grep ^alias</span><br><span class="line">head = rev-list -n1 --abbrev-commit HEAD</span><br><span class="line">        l = log --stat --color --graph --pretty=format:&#x27;%C(bold red)%h%C(reset) - %C(bold green)(%cr)%C(bold blue)&lt;%an&gt;%C(reset) -%C(bold yellow)%d%C(reset) %s&#x27; --abbrev-commit</span><br><span class="line">[init]</span><br><span class="line">        defaultBranch = main</span><br></pre></td></tr></table></figure><h3 id="1-3- 修改本地 -branch-name"><a href="#1-3- 修改本地 -branch-name" class="headerlink" title="1.3 修改本地 branch name"></a>1.3 修改本地 branch name</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git branch -m master main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -m old_branch new_branch <span class="comment"># Rename branch locally</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :old_branch <span class="comment"># Delete the old branch</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --set-upstream origin new_branch <span class="comment"># Push the new branch, set local branch to track the new remote</span></span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">enwaiax@enwaiax-dev /tmp/test master→ origin/main ⇡</span><br><span class="line">/tmp/test master:main ⇡1</span><br><span class="line">❯</span><br><span class="line"></span><br><span class="line">/tmp/test master:main ⇡1</span><br><span class="line">❯ git branch -m master main</span><br><span class="line"></span><br><span class="line">enwaiax@enwaiax-dev /tmp/test main ⇡</span><br><span class="line">/tmp/test main ⇡1                                                                          ❯</span><br></pre></td></tr></table></figure><h2 id="2-commit- 本地改动"><a href="#2-commit- 本地改动" class="headerlink" title="2. commit 本地改动"></a>2. commit 本地改动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add .</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Adds the files <span class="keyword">in</span> the <span class="built_in">local</span> repository and stages them <span class="keyword">for</span> commit. To unstage a file, use <span class="string">&#x27;git reset HEAD YOUR-FILE&#x27;</span>.</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;First commit&quot;</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Commits the tracked changes and prepares them to be pushed to a remote repository. To remove this commit and modify the file, use <span class="string">&#x27;git reset --soft HEAD~1&#x27;</span> and commit and add the file again.</span></span><br></pre></td></tr></table></figure><h2 id="3- 设置远程仓库"><a href="#3- 设置远程仓库" class="headerlink" title="3. 设置远程仓库"></a>3. <a href="https://docs.github.com/en/get-started/getting-started-with-git/managing-remote-repositories">设置远程仓库</a></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add origin  &lt;REMOTE_URL&gt;</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Sets the new remote</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Verifies the new remote URL</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4- 设置与远程仓库同步"><a href="#4- 设置与远程仓库同步" class="headerlink" title="4. 设置与远程仓库同步"></a>4. 设置与远程仓库同步</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/&lt;branch&gt; &lt;local_branch&gt;</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/main main</span></span><br></pre></td></tr></table></figure><h2 id="5-Git- 相关常用指令"><a href="#5-Git- 相关常用指令" class="headerlink" title="5. Git 相关常用指令"></a>5. Git 相关常用指令 </h2><h3 id="git-push-origin- 与 -git-push-u-origin-master- 的区别"><a href="#git-push-origin- 与 -git-push-u-origin-master- 的区别" class="headerlink" title="git push origin 与 git push -u origin master 的区别"></a>git push origin 与 git push -u origin master 的区别</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br><span class="line"> 将当前分支推送到 origin 主机的对应分支。 其中 origin 可通过 `git remote -v` 查看 </span><br><span class="line"></span><br><span class="line">❯ git remote -v</span><br><span class="line">origin  https://github.com/Chasing66/learn-go-with-tests.git (fetch)</span><br><span class="line">origin  https://github.com/Chasing66/learn-go-with-tests.git (push)</span><br><span class="line"></span><br><span class="line"> 如果当前分支只有一个追踪分支，那么主机名都可以省略。</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push 如果当前分支与多个主机存在追踪关系，那么这个时候 -u 选项会指定一个默认主机，这样后面就可以不加任何参数使用 git push。</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u origin master 上面命令将本地的 master 分支推送到 origin 主机，同时指定 origin 为默认主机，后面就可以不加任何参数使用 git push 了。</span></span><br><span class="line"></span><br><span class="line">不带任何参数的 git push，默认只推送当前分支，这叫做 simple 方式。此外，还有一种 matching 方式，会推送所有有对应的远程分支的本地分支。Git 2.0 版本之前，默认采用 matching 方法，现在改为默认采用 simple 方式。</span><br></pre></td></tr></table></figure><h2 id="参考文档"><a href="# 参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://github.com/521xueweihan/git-tips">git_tips</a></li><li><a href="https://rogerdudler.github.io/git-guide/index.zh.html">git - 简明指南</a></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GitHub x Pages 搭建静态化 Hexo 博客</title>
      <link href="/posts/3004/"/>
      <url>/posts/3004/</url>
      
        <content type="html"><![CDATA[<h2 id="1- 安装基本环境"><a href="#1- 安装基本环境" class="headerlink" title="1. 安装基本环境"></a>1. 安装基本环境</h2><h3 id="1-1- 安装 -git"><a href="#1-1- 安装 -git" class="headerlink" title="1.1 安装 git"></a>1.1 安装 git</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install git</span><br></pre></td></tr></table></figure><h3 id="1-2- 利用 -nvm- 安装 -nodejs"><a href="#1-2- 利用 -nvm- 安装 -nodejs" class="headerlink" title="1.2 利用 nvm 安装 nodejs"></a>1.2 利用 nvm 安装 nodejs</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</span><br><span class="line">exec $SHELL</span><br><span class="line">nvm install --lts</span><br></pre></td></tr></table></figure><span id="more"></span><h4 id="1-2-1- 安装 -hexo"><a href="#1-2-1- 安装 -hexo" class="headerlink" title="1.2.1 安装 hexo"></a>1.2.1 安装 hexo</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g</span><br></pre></td></tr></table></figure><h2 id="2- 初始化 -hexo- 项目"><a href="#2- 初始化 -hexo- 项目" class="headerlink" title="2. 初始化 hexo 项目"></a>2. 初始化 hexo 项目</h2><h3 id="2-1- 创建初始化项目"><a href="#2-1- 创建初始化项目" class="headerlink" title="2.1 创建初始化项目"></a>2.1 创建初始化项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init MyNote</span><br></pre></td></tr></table></figure><h4 id="2-2- 安装 -next- 主题以及 -hexo-deployer-git- 工具"><a href="#2-2- 安装 -next- 主题以及 -hexo-deployer-git- 工具" class="headerlink" title="2.2 安装 next 主题以及 hexo-deployer-git 工具"></a>2.2 安装 next 主题以及 hexo-deployer-git 工具 </h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"> 在 MyNote 文件夹下执行</span></span><br><span class="line">npm install hexo-theme-next hexo-deployer-git</span><br></pre></td></tr></table></figure><h2 id="3- 配置 -config-yaml- 文件"><a href="#3- 配置 -config-yaml- 文件" class="headerlink" title="3. 配置_config.yaml 文件"></a>3. 配置_config.yaml 文件 </h2><p> 修改博客标题等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title: &quot;LuckyHunter&#x27;s notes&quot;</span><br><span class="line">subtitle: &#x27;Quick notes&#x27;</span><br><span class="line">description: &#x27;Stay hungry, stay foolish.&#x27;</span><br><span class="line">keywords:</span><br><span class="line">author: LuckyHunter</span><br><span class="line">language: zh-CN</span><br><span class="line">timezone: &#x27;&#x27;</span><br></pre></td></tr></table></figure><p>修改 deploy 部分，连接到 github 仓库地址，此处需要确保当前环境有权限 push 到该仓库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: &#x27;git&#x27;</span><br><span class="line">  branch: &#x27;main&#x27;</span><br><span class="line">  repo: &#x27;https://github.com/enwaiax/enwaiax.github.io.git&#x27;</span><br></pre></td></tr></table></figure><p>修改主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Installed through npm</span><br><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br><span class="line"># Installed through Git</span><br><span class="line">cp themes/next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure><h2 id="4- 本地测试"><a href="#4- 本地测试" class="headerlink" title="4. 本地测试"></a>4. 本地测试</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="5- 发布到 -github-pages"><a href="#5- 发布到 -github-pages" class="headerlink" title="5. 发布到 github pages"></a>5. 发布到 github pages</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
